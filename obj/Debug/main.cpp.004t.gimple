main ()
{
  int D.105366;
  bool retval.0;
  bool retval.1;
  ssizetype D.105379;
  sizetype D.105380;
  bitsizetype D.105381;
  sizetype D.105382;
  bitsizetype D.105383;
  sizetype D.105384;
  float[0:D.105380] * vertices.3;
  bool retval.4;
  bool retval.20;
  struct vec3 D.100851;
  struct vec3 D.100870;
  const struct string D.100890;
  struct allocator D.100889;
  void * saved_stack.31;

  {
    struct GLFWwindow * window;
    struct Shader ourShader;
    int linhas;
    int i;
    char c;
    char linha[100];
    char * pch;
    struct FILE * arqin;
    float vertices[0:D.105380] [value-expr: *vertices.3];
    unsigned int VBO;
    unsigned int VAO;

    saved_stack.31 = __builtin_stack_save ();
    try
      {
        glfwInit ();
        glfwWindowHint (139266, 3);
        glfwWindowHint (139267, 3);
        glfwWindowHint (139272, 204801);
        window = glfwCreateWindow (800, 600, "OPenGL : TDE 2 - 3D", 0B, 0B);
        if (window == 0B) goto <D.105364>; else goto <D.105365>;
        <D.105364>:
        _1 = std::operator<< <std::char_traits<char> > (&cout, "Failed to create GLFW window");
        std::basic_ostream<char>::operator<< (_1, endl);
        glfwTerminate ();
        D.105366 = -1;
        // predicted unlikely by early return (on trees) predictor.
        return D.105366;
        <D.105365>:
        glfwMakeContextCurrent (window);
        glfwSetFramebufferSizeCallback (window, framebuffer_size_callback);
        _2 = glewInit ();
        retval.0 = _2 != 0;
        if (retval.0 != 0) goto <D.105368>; else goto <D.105369>;
        <D.105368>:
        _3 = std::operator<< <std::char_traits<char> > (&cout, "Ocorreu um erro iniciando GLEW!");
        std::basic_ostream<char>::operator<< (_3, endl);
        goto <D.105370>;
        <D.105369>:
        _4 = std::operator<< <std::char_traits<char> > (&cout, "GLEW OK!");
        std::basic_ostream<char>::operator<< (_4, endl);
        _5 = glGetString (7938);
        _6 = std::operator<< <std::char_traits<char> > (&cout, _5);
        std::basic_ostream<char>::operator<< (_6, endl);
        <D.105370>:
        glEnable (2929);
        Shader::Shader (&ourShader, "vertex.glsl", "fragment.glsl", 0B);
        linhas = 1;
        i = 0;
        arqin = fopen ("casa.csv", "rt");
        if (arqin == 0B) goto <D.105371>; else goto <D.105372>;
        <D.105371>:
        printf ("Erro na abertura de %s %d\n", "casa.csv", 8);
        exit (0);
        <D.105372>:
        <D.105373>:
        _7 = fread (&c, 1, 1, arqin);
        retval.1 = _7 != 0;
        if (retval.1 != 0) goto <D.105375>; else goto <D.100891>;
        <D.105375>:
        c.2_8 = c;
        if (c.2_8 == 10) goto <D.105376>; else goto <D.105377>;
        <D.105376>:
        linhas = linhas + 1;
        goto <D.105378>;
        <D.105377>:
        <D.105378>:
        goto <D.105373>;
        <D.100891>:
        printf ("Linhas: %d \n", linhas);
        _9 = linhas * 8;
        _10 = (ssizetype) _9;
        D.105379 = _10 + -1;
        D.105380 = (sizetype) D.105379;
        _12 = (sizetype) D.105379;
        _13 = _12 + 1;
        _14 = (bitsizetype) _13;
        D.105381 = _14 * 32;
        _16 = (sizetype) D.105379;
        _17 = _16 + 1;
        D.105382 = _17 * 4;
        _19 = (sizetype) D.105379;
        _20 = _19 + 1;
        _21 = (bitsizetype) _20;
        D.105383 = _21 * 32;
        _23 = (sizetype) D.105379;
        _24 = _23 + 1;
        D.105384 = _24 * 4;
        vertices.3 = __builtin_alloca_with_align (D.105384, 32);
        fclose (arqin);
        i = 0;
        fopen ("casa.csv", "rt");
        <D.105386>:
        _26 = feof (arqin);
        retval.4 = _26 == 0;
        if (retval.4 != 0) goto <D.105388>; else goto <D.100893>;
        <D.105388>:
        {
          fgets (&linha, 100, arqin);
          pch = strtok (&linha, ";");
          <D.105389>:
          if (pch == 0B) goto <D.100895>; else goto <D.105390>;
          <D.105390>:
          {
            int validarNumerico;

            validarNumerico = strcmp (pch, "\n");
            if (validarNumerico != 0) goto <D.105391>; else goto <D.105392>;
            <D.105391>:
            _27 = atof (pch);
            vertices.5_28 = vertices.3;
            _29 = (long long unsigned int) i;
            _30 = _29 * 4;
            _31 = vertices.5_28 + _30;
            _32 = (float) _27;
            *_31 = _32;
            _33 = *vertices.3[i];
            _34 = (double) _33;
            printf ("vertices[%d]: %f\n ", i, _34);
            i = i + 1;
            goto <D.105393>;
            <D.105392>:
            <D.105393>:
            pch = strtok (0B, ";");
          }
          goto <D.105389>;
          <D.100895>:
        }
        goto <D.105386>;
        <D.100893>:
        fclose (arqin);
        __glewGenVertexArrays.6_35 = __glewGenVertexArrays;
        __glewGenVertexArrays.6_35 (1, &VAO);
        __glewGenBuffers.7_36 = __glewGenBuffers;
        __glewGenBuffers.7_36 (1, &VBO);
        __glewBindVertexArray.8_37 = __glewBindVertexArray;
        VAO.9_38 = VAO;
        __glewBindVertexArray.8_37 (VAO.9_38);
        __glewBindBuffer.10_39 = __glewBindBuffer;
        VBO.11_40 = VBO;
        __glewBindBuffer.10_39 (34962, VBO.11_40);
        __glewBufferData.12_41 = __glewBufferData;
        vertices.13_42 = vertices.3;
        _43 = (sizetype) D.105379;
        _44 = _43 + 1;
        _45 = _44 * 4;
        _46 = (long long int) _45;
        __glewBufferData.12_41 (34962, _46, vertices.13_42, 35044);
        __glewVertexAttribPointer.14_47 = __glewVertexAttribPointer;
        __glewVertexAttribPointer.14_47 (0, 3, 5126, 0, 32, 0B);
        __glewEnableVertexAttribArray.15_48 = __glewEnableVertexAttribArray;
        __glewEnableVertexAttribArray.15_48 (0);
        __glewVertexAttribPointer.16_49 = __glewVertexAttribPointer;
        __glewVertexAttribPointer.16_49 (1, 3, 5126, 0, 32, 12B);
        __glewEnableVertexAttribArray.17_50 = __glewEnableVertexAttribArray;
        __glewEnableVertexAttribArray.17_50 (1);
        __glewVertexAttribPointer.18_51 = __glewVertexAttribPointer;
        __glewVertexAttribPointer.18_51 (2, 2, 5126, 0, 32, 12B);
        __glewEnableVertexAttribArray.19_52 = __glewEnableVertexAttribArray;
        __glewEnableVertexAttribArray.19_52 (2);
        <D.105394>:
        _53 = glfwWindowShouldClose (window);
        retval.20 = _53 == 0;
        if (retval.20 != 0) goto <D.105396>; else goto <D.100897>;
        <D.105396>:
        {
          struct mat4 model;
          struct mat4 view;
          struct mat4 projection;
          unsigned int modelLoc;
          unsigned int viewLoc;

          try
            {
              processInput (window);
              glClearColor (0.0, 0.0, 0.0, 1.0e+0);
              glClear (16640);
              Shader::use (&ourShader);
              model.value[0].D.51351.x = 1.0e+0;
              model.value[0].D.51357.y = 0.0;
              model.value[0].D.51363.z = 0.0;
              model.value[0].D.51369.w = 0.0;
              model.value[1].D.51351.x = 0.0;
              model.value[1].D.51357.y = 1.0e+0;
              model.value[1].D.51363.z = 0.0;
              model.value[1].D.51369.w = 0.0;
              model.value[2].D.51351.x = 0.0;
              model.value[2].D.51357.y = 0.0;
              model.value[2].D.51363.z = 1.0e+0;
              model.value[2].D.51369.w = 0.0;
              model.value[3].D.51351.x = 0.0;
              model.value[3].D.51357.y = 0.0;
              model.value[3].D.51363.z = 0.0;
              model.value[3].D.51369.w = 1.0e+0;
              view.value[0].D.51351.x = 1.0e+0;
              view.value[0].D.51357.y = 0.0;
              view.value[0].D.51363.z = 0.0;
              view.value[0].D.51369.w = 0.0;
              view.value[1].D.51351.x = 0.0;
              view.value[1].D.51357.y = 1.0e+0;
              view.value[1].D.51363.z = 0.0;
              view.value[1].D.51369.w = 0.0;
              view.value[2].D.51351.x = 0.0;
              view.value[2].D.51357.y = 0.0;
              view.value[2].D.51363.z = 1.0e+0;
              view.value[2].D.51369.w = 0.0;
              view.value[3].D.51351.x = 0.0;
              view.value[3].D.51357.y = 0.0;
              view.value[3].D.51363.z = 0.0;
              view.value[3].D.51369.w = 1.0e+0;
              projection.value[0].D.51351.x = 1.0e+0;
              projection.value[0].D.51357.y = 0.0;
              projection.value[0].D.51363.z = 0.0;
              projection.value[0].D.51369.w = 0.0;
              projection.value[1].D.51351.x = 0.0;
              projection.value[1].D.51357.y = 1.0e+0;
              projection.value[1].D.51363.z = 0.0;
              projection.value[1].D.51369.w = 0.0;
              projection.value[2].D.51351.x = 0.0;
              projection.value[2].D.51357.y = 0.0;
              projection.value[2].D.51363.z = 1.0e+0;
              projection.value[2].D.51369.w = 0.0;
              projection.value[3].D.51351.x = 0.0;
              projection.value[3].D.51357.y = 0.0;
              projection.value[3].D.51363.z = 0.0;
              projection.value[3].D.51369.w = 1.0e+0;
              glm::vec<3, float, (glm::qualifier)0>::vec (&D.100851, 1.00000001490116119384765625e-1, 0.0, 0.0);
              try
                {
                  _54 = glm::radians<float> (5.5e+1);
                  model = glm::rotate<float, (glm::qualifier)0> (&model, _54, &D.100851);
                }
              finally
                {
                  D.100851 = {CLOBBER};
                }
              glm::vec<3, float, (glm::qualifier)0>::vec (&D.100870, 0.0, 0.0, -3.0e+0);
              try
                {
                  view = glm::translate<float, (glm::qualifier)0> (&view, &D.100870);
                }
              finally
                {
                  D.100870 = {CLOBBER};
                }
              _55 = glm::radians<float> (4.5e+1);
              projection = glm::perspective<float> (_55, 1.33333337306976318359375e+0, 1.00000001490116119384765625e-1, 1.0e+2);
              __glewGetUniformLocation.21_56 = __glewGetUniformLocation;
              _57 = ourShader.ID;
              _58 = __glewGetUniformLocation.21_56 (_57, "model");
              modelLoc = (unsigned int) _58;
              __glewGetUniformLocation.22_59 = __glewGetUniformLocation;
              _60 = ourShader.ID;
              _61 = __glewGetUniformLocation.22_59 (_60, "view");
              viewLoc = (unsigned int) _61;
              __glewUniformMatrix4fv.23_62 = __glewUniformMatrix4fv;
              _63 = glm::value_ptr<float, (glm::qualifier)0> (&model);
              modelLoc.24_64 = (int) modelLoc;
              __glewUniformMatrix4fv.23_62 (modelLoc.24_64, 1, 0, _63);
              __glewUniformMatrix4fv.25_65 = __glewUniformMatrix4fv;
              _66 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&view, 0);
              _67 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_66, 0);
              viewLoc.26_68 = (int) viewLoc;
              __glewUniformMatrix4fv.25_65 (viewLoc.26_68, 1, 0, _67);
              std::allocator<char>::allocator (&D.100889);
              try
                {
                  try
                    {
                      std::__cxx11::basic_string<char>::basic_string (&D.100890, "projection", &D.100889);
                      try
                        {
                          try
                            {
                              Shader::setMat4 (&ourShader, &D.100890, &projection);
                            }
                          finally
                            {
                              std::__cxx11::basic_string<char>::~basic_string (&D.100890);
                            }
                        }
                      finally
                        {
                          D.100890 = {CLOBBER};
                        }
                    }
                  finally
                    {
                      std::allocator<char>::~allocator (&D.100889);
                    }
                }
              finally
                {
                  D.100889 = {CLOBBER};
                }
              __glewBindVertexArray.27_69 = __glewBindVertexArray;
              VAO.28_70 = VAO;
              __glewBindVertexArray.27_69 (VAO.28_70);
              glDrawArrays (4, 0, 36);
              glfwSwapBuffers (window);
              glfwPollEvents ();
            }
          finally
            {
              model = {CLOBBER};
              view = {CLOBBER};
              projection = {CLOBBER};
            }
        }
        goto <D.105394>;
        <D.100897>:
        __glewDeleteVertexArrays.29_71 = __glewDeleteVertexArrays;
        __glewDeleteVertexArrays.29_71 (1, &VAO);
        __glewDeleteBuffers.30_72 = __glewDeleteBuffers;
        __glewDeleteBuffers.30_72 (1, &VBO);
        glfwTerminate ();
        D.105366 = 0;
        return D.105366;
      }
    finally
      {
        __builtin_stack_restore (saved_stack.31);
        ourShader = {CLOBBER};
        c = {CLOBBER};
        linha = {CLOBBER};
        VBO = {CLOBBER};
        VAO = {CLOBBER};
      }
  }
  D.105366 = 0;
  return D.105366;
}


Shader::Shader (struct Shader * const this, const char * vertexPath, const char * fragmentPath, const char * geometryPath)
{
  struct __string_type D.95527;
  struct __string_type D.95528;
  struct __string_type D.95530;
  register struct failure * D.95532;
  struct string D.95533;
  struct allocator D.95534;
  struct string D.95535;
  struct allocator D.95536;
  struct string D.95538;
  struct allocator D.95539;
  struct string D.95540;
  struct allocator D.95541;

  MEM[(struct  &)this] = {CLOBBER};
  {
    {
      struct string vertexCode;
      struct string fragmentCode;
      struct string geometryCode;
      struct ifstream vShaderFile;
      struct ifstream fShaderFile;
      struct ifstream gShaderFile;
      const char * vShaderCode;
      const char * fShaderCode;
      unsigned int vertex;
      unsigned int fragment;
      unsigned int geometry;

      try
        {
          std::__cxx11::basic_string<char>::basic_string (&vertexCode);
          try
            {
              std::__cxx11::basic_string<char>::basic_string (&fragmentCode);
              try
                {
                  std::__cxx11::basic_string<char>::basic_string (&geometryCode);
                  try
                    {
                      std::basic_ifstream<char>::basic_ifstream (&vShaderFile);
                      try
                        {
                          std::basic_ifstream<char>::basic_ifstream (&fShaderFile);
                          try
                            {
                              std::basic_ifstream<char>::basic_ifstream (&gShaderFile);
                              try
                                {
                                  _1 = std::operator| (4, 1);
                                  std::basic_ios<char>::exceptions (&vShaderFile.D.92731, _1);
                                  _2 = std::operator| (4, 1);
                                  std::basic_ios<char>::exceptions (&fShaderFile.D.92731, _2);
                                  _3 = std::operator| (4, 1);
                                  std::basic_ios<char>::exceptions (&gShaderFile.D.92731, _3);
                                  try
                                    {
                                      {
                                        struct stringstream vShaderStream;
                                        struct stringstream fShaderStream;

                                        try
                                          {
                                            std::basic_ifstream<char>::open (&vShaderFile, vertexPath, 8);
                                            std::basic_ifstream<char>::open (&fShaderFile, fragmentPath, 8);
                                            _4 = std::operator| (16, 8);
                                            std::__cxx11::basic_stringstream<char>::basic_stringstream (&vShaderStream, _4);
                                            try
                                              {
                                                _5 = std::operator| (16, 8);
                                                std::__cxx11::basic_stringstream<char>::basic_stringstream (&fShaderStream, _5);
                                                try
                                                  {
                                                    _6 = std::basic_ifstream<char>::rdbuf (&vShaderFile);
                                                    std::basic_ostream<char>::operator<< (&vShaderStream.D.94702.D.89313, _6);
                                                    _7 = std::basic_ifstream<char>::rdbuf (&fShaderFile);
                                                    std::basic_ostream<char>::operator<< (&fShaderStream.D.94702.D.89313, _7);
                                                    std::basic_ifstream<char>::close (&vShaderFile);
                                                    std::basic_ifstream<char>::close (&fShaderFile);
                                                    D.95527 = std::__cxx11::basic_stringstream<char>::str (&vShaderStream); [return slot optimization]
                                                    try
                                                      {
                                                        try
                                                          {
                                                            std::__cxx11::basic_string<char>::operator= (&vertexCode, &D.95527);
                                                          }
                                                        finally
                                                          {
                                                            std::__cxx11::basic_string<char>::~basic_string (&D.95527);
                                                          }
                                                      }
                                                    finally
                                                      {
                                                        D.95527 = {CLOBBER};
                                                      }
                                                    D.95528 = std::__cxx11::basic_stringstream<char>::str (&fShaderStream); [return slot optimization]
                                                    try
                                                      {
                                                        try
                                                          {
                                                            std::__cxx11::basic_string<char>::operator= (&fragmentCode, &D.95528);
                                                          }
                                                        finally
                                                          {
                                                            std::__cxx11::basic_string<char>::~basic_string (&D.95528);
                                                          }
                                                      }
                                                    finally
                                                      {
                                                        D.95528 = {CLOBBER};
                                                      }
                                                    {
                                                      if (geometryPath != 0B) goto <D.105424>; else goto <D.105425>;
                                                      <D.105424>:
                                                      {
                                                        struct stringstream gShaderStream;

                                                        try
                                                          {
                                                            std::basic_ifstream<char>::open (&gShaderFile, geometryPath, 8);
                                                            _8 = std::operator| (16, 8);
                                                            std::__cxx11::basic_stringstream<char>::basic_stringstream (&gShaderStream, _8);
                                                            try
                                                              {
                                                                _9 = std::basic_ifstream<char>::rdbuf (&gShaderFile);
                                                                std::basic_ostream<char>::operator<< (&gShaderStream.D.94702.D.89313, _9);
                                                                std::basic_ifstream<char>::close (&gShaderFile);
                                                                D.95530 = std::__cxx11::basic_stringstream<char>::str (&gShaderStream); [return slot optimization]
                                                                try
                                                                  {
                                                                    try
                                                                      {
                                                                        std::__cxx11::basic_string<char>::operator= (&geometryCode, &D.95530);
                                                                      }
                                                                    finally
                                                                      {
                                                                        std::__cxx11::basic_string<char>::~basic_string (&D.95530);
                                                                      }
                                                                  }
                                                                finally
                                                                  {
                                                                    D.95530 = {CLOBBER};
                                                                  }
                                                              }
                                                            finally
                                                              {
                                                                std::__cxx11::basic_stringstream<char>::~basic_stringstream (&gShaderStream);
                                                              }
                                                          }
                                                        finally
                                                          {
                                                            gShaderStream = {CLOBBER};
                                                          }
                                                      }
                                                      goto <D.105426>;
                                                      <D.105425>:
                                                      <D.105426>:
                                                    }
                                                  }
                                                finally
                                                  {
                                                    std::__cxx11::basic_stringstream<char>::~basic_stringstream (&fShaderStream);
                                                  }
                                              }
                                            finally
                                              {
                                                std::__cxx11::basic_stringstream<char>::~basic_stringstream (&vShaderStream);
                                              }
                                          }
                                        finally
                                          {
                                            vShaderStream = {CLOBBER};
                                            fShaderStream = {CLOBBER};
                                          }
                                      }
                                    }
                                  catch
                                    {
                                      catch (struct failure)
                                        {
                                          {
                                            struct failure & e;

                                            try
                                              {
                                                _10 = __builtin_eh_pointer (0);
                                                D.95532 = __cxa_begin_catch (_10);
                                                e = D.95532;
                                                _11 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ");
                                                std::basic_ostream<char>::operator<< (_11, endl);
                                              }
                                            finally
                                              {
                                                __cxa_end_catch ();
                                              }
                                          }
                                        }
                                    }
                                  _12 = std::__cxx11::basic_string<char>::c_str (&vertexCode);
                                  vShaderCode = _12;
                                  _13 = std::__cxx11::basic_string<char>::c_str (&fragmentCode);
                                  fShaderCode = _13;
                                  __glewCreateShader.32_14 = __glewCreateShader;
                                  vertex = __glewCreateShader.32_14 (35633);
                                  __glewShaderSource.33_15 = __glewShaderSource;
                                  __glewShaderSource.33_15 (vertex, 1, &vShaderCode, 0B);
                                  __glewCompileShader.34_16 = __glewCompileShader;
                                  __glewCompileShader.34_16 (vertex);
                                  std::allocator<char>::allocator (&D.95534);
                                  try
                                    {
                                      try
                                        {
                                          std::__cxx11::basic_string<char>::basic_string (&D.95533, "VERTEX", &D.95534);
                                          try
                                            {
                                              try
                                                {
                                                  Shader::checkCompileErrors (this, vertex, &D.95533);
                                                }
                                              finally
                                                {
                                                  std::__cxx11::basic_string<char>::~basic_string (&D.95533);
                                                }
                                            }
                                          finally
                                            {
                                              D.95533 = {CLOBBER};
                                            }
                                        }
                                      finally
                                        {
                                          std::allocator<char>::~allocator (&D.95534);
                                        }
                                    }
                                  finally
                                    {
                                      D.95534 = {CLOBBER};
                                    }
                                  __glewCreateShader.35_17 = __glewCreateShader;
                                  fragment = __glewCreateShader.35_17 (35632);
                                  __glewShaderSource.36_18 = __glewShaderSource;
                                  __glewShaderSource.36_18 (fragment, 1, &fShaderCode, 0B);
                                  __glewCompileShader.37_19 = __glewCompileShader;
                                  __glewCompileShader.37_19 (fragment);
                                  std::allocator<char>::allocator (&D.95536);
                                  try
                                    {
                                      try
                                        {
                                          std::__cxx11::basic_string<char>::basic_string (&D.95535, "FRAGMENT", &D.95536);
                                          try
                                            {
                                              try
                                                {
                                                  Shader::checkCompileErrors (this, fragment, &D.95535);
                                                }
                                              finally
                                                {
                                                  std::__cxx11::basic_string<char>::~basic_string (&D.95535);
                                                }
                                            }
                                          finally
                                            {
                                              D.95535 = {CLOBBER};
                                            }
                                        }
                                      finally
                                        {
                                          std::allocator<char>::~allocator (&D.95536);
                                        }
                                    }
                                  finally
                                    {
                                      D.95536 = {CLOBBER};
                                    }
                                  {
                                    if (geometryPath != 0B) goto <D.105427>; else goto <D.105428>;
                                    <D.105427>:
                                    {
                                      const char * gShaderCode;

                                      try
                                        {
                                          _20 = std::__cxx11::basic_string<char>::c_str (&geometryCode);
                                          gShaderCode = _20;
                                          __glewCreateShader.38_21 = __glewCreateShader;
                                          geometry = __glewCreateShader.38_21 (36313);
                                          __glewShaderSource.39_22 = __glewShaderSource;
                                          __glewShaderSource.39_22 (geometry, 1, &gShaderCode, 0B);
                                          __glewCompileShader.40_23 = __glewCompileShader;
                                          __glewCompileShader.40_23 (geometry);
                                          std::allocator<char>::allocator (&D.95539);
                                          try
                                            {
                                              try
                                                {
                                                  std::__cxx11::basic_string<char>::basic_string (&D.95538, "GEOMETRY", &D.95539);
                                                  try
                                                    {
                                                      try
                                                        {
                                                          Shader::checkCompileErrors (this, geometry, &D.95538);
                                                        }
                                                      finally
                                                        {
                                                          std::__cxx11::basic_string<char>::~basic_string (&D.95538);
                                                        }
                                                    }
                                                  finally
                                                    {
                                                      D.95538 = {CLOBBER};
                                                    }
                                                }
                                              finally
                                                {
                                                  std::allocator<char>::~allocator (&D.95539);
                                                }
                                            }
                                          finally
                                            {
                                              D.95539 = {CLOBBER};
                                            }
                                        }
                                      finally
                                        {
                                          gShaderCode = {CLOBBER};
                                        }
                                    }
                                    goto <D.105429>;
                                    <D.105428>:
                                    <D.105429>:
                                  }
                                  __glewCreateProgram.41_24 = __glewCreateProgram;
                                  _25 = __glewCreateProgram.41_24 ();
                                  this->ID = _25;
                                  __glewAttachShader.42_26 = __glewAttachShader;
                                  _27 = this->ID;
                                  __glewAttachShader.42_26 (_27, vertex);
                                  __glewAttachShader.43_28 = __glewAttachShader;
                                  _29 = this->ID;
                                  __glewAttachShader.43_28 (_29, fragment);
                                  if (geometryPath != 0B) goto <D.105430>; else goto <D.105431>;
                                  <D.105430>:
                                  __glewAttachShader.44_30 = __glewAttachShader;
                                  _31 = this->ID;
                                  __glewAttachShader.44_30 (_31, geometry);
                                  goto <D.105432>;
                                  <D.105431>:
                                  <D.105432>:
                                  __glewLinkProgram.45_32 = __glewLinkProgram;
                                  _33 = this->ID;
                                  __glewLinkProgram.45_32 (_33);
                                  std::allocator<char>::allocator (&D.95541);
                                  try
                                    {
                                      try
                                        {
                                          std::__cxx11::basic_string<char>::basic_string (&D.95540, "PROGRAM", &D.95541);
                                          try
                                            {
                                              try
                                                {
                                                  _34 = this->ID;
                                                  Shader::checkCompileErrors (this, _34, &D.95540);
                                                }
                                              finally
                                                {
                                                  std::__cxx11::basic_string<char>::~basic_string (&D.95540);
                                                }
                                            }
                                          finally
                                            {
                                              D.95540 = {CLOBBER};
                                            }
                                        }
                                      finally
                                        {
                                          std::allocator<char>::~allocator (&D.95541);
                                        }
                                    }
                                  finally
                                    {
                                      D.95541 = {CLOBBER};
                                    }
                                  __glewDeleteShader.46_35 = __glewDeleteShader;
                                  __glewDeleteShader.46_35 (vertex);
                                  __glewDeleteShader.47_36 = __glewDeleteShader;
                                  __glewDeleteShader.47_36 (fragment);
                                  if (geometryPath != 0B) goto <D.105433>; else goto <D.105434>;
                                  <D.105433>:
                                  __glewDeleteShader.48_37 = __glewDeleteShader;
                                  __glewDeleteShader.48_37 (geometry);
                                  goto <D.105435>;
                                  <D.105434>:
                                  <D.105435>:
                                }
                              finally
                                {
                                  std::basic_ifstream<char>::~basic_ifstream (&gShaderFile);
                                }
                            }
                          finally
                            {
                              std::basic_ifstream<char>::~basic_ifstream (&fShaderFile);
                            }
                        }
                      finally
                        {
                          std::basic_ifstream<char>::~basic_ifstream (&vShaderFile);
                        }
                    }
                  finally
                    {
                      std::__cxx11::basic_string<char>::~basic_string (&geometryCode);
                    }
                }
              finally
                {
                  std::__cxx11::basic_string<char>::~basic_string (&fragmentCode);
                }
            }
          finally
            {
              std::__cxx11::basic_string<char>::~basic_string (&vertexCode);
            }
        }
      finally
        {
          vertexCode = {CLOBBER};
          fragmentCode = {CLOBBER};
          geometryCode = {CLOBBER};
          vShaderFile = {CLOBBER};
          fShaderFile = {CLOBBER};
          gShaderFile = {CLOBBER};
          vShaderCode = {CLOBBER};
          fShaderCode = {CLOBBER};
        }
    }
  }
}


std::__cxx11::basic_string<char>::basic_string (struct basic_string * const this)
{
  struct allocator D.103059;

  try
    {
      MEM[(struct  &)this] = {CLOBBER};
      {
        _1 = &this->_M_dataplus;
        std::allocator<char>::allocator (&D.103059);
        try
          {
            try
              {
                _2 = std::__cxx11::basic_string<char>::_M_local_data (this);
                std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _2, &D.103059);
              }
            finally
              {
                std::allocator<char>::~allocator (&D.103059);
              }
          }
        finally
          {
            D.103059 = {CLOBBER};
          }
        try
          {
            std::__cxx11::basic_string<char>::_M_set_length (this, 0);
          }
        catch
          {
            _3 = &this->_M_dataplus;
            std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_3);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, struct allocator & __a)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    _1 = std::move<std::allocator<char>&> (__a);
    std::allocator<char>::allocator (this, _1);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


std::move<std::allocator<char>&> (struct allocator & __t)
{
  struct type & D.105478;

  try
    {
      D.105478 = __t;
      return D.105478;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::operator| (_Ios_Iostate __a, _Ios_Iostate __b)
{
  _Ios_Iostate D.105480;

  D.105480 = __a | __b;
  return D.105480;
}


std::operator| (_Ios_Openmode __a, _Ios_Openmode __b)
{
  _Ios_Openmode D.105482;

  D.105482 = __a | __b;
  return D.105482;
}


Shader::checkCompileErrors (struct Shader * const this, GLuint shader, struct string & restrict type)
{
  bool retval.49;
  GLint success;
  GLchar infoLog[1024];

  try
    {
      retval.49 = std::operator!=<char, std::char_traits<char>, std::allocator<char> > (type, "PROGRAM");
      if (retval.49 != 0) goto <D.105485>; else goto <D.105486>;
      <D.105485>:
      __glewGetShaderiv.50_1 = __glewGetShaderiv;
      __glewGetShaderiv.50_1 (shader, 35713, &success);
      success.51_2 = success;
      if (success.51_2 == 0) goto <D.105487>; else goto <D.105488>;
      <D.105487>:
      __glewGetShaderInfoLog.52_3 = __glewGetShaderInfoLog;
      __glewGetShaderInfoLog.52_3 (shader, 1024, 0B, &infoLog);
      _4 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::SHADER_COMPILATION_ERROR of type: ");
      _5 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (_4, type);
      _6 = std::operator<< <std::char_traits<char> > (_5, "\n");
      _7 = std::operator<< <std::char_traits<char> > (_6, &infoLog);
      _8 = std::operator<< <std::char_traits<char> > (_7, "\n -- --------------------------------------------------- -- ");
      std::basic_ostream<char>::operator<< (_8, endl);
      goto <D.105489>;
      <D.105488>:
      <D.105489>:
      goto <D.105490>;
      <D.105486>:
      __glewGetProgramiv.53_9 = __glewGetProgramiv;
      __glewGetProgramiv.53_9 (shader, 35714, &success);
      success.54_10 = success;
      if (success.54_10 == 0) goto <D.105491>; else goto <D.105492>;
      <D.105491>:
      __glewGetProgramInfoLog.55_11 = __glewGetProgramInfoLog;
      __glewGetProgramInfoLog.55_11 (shader, 1024, 0B, &infoLog);
      _12 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::PROGRAM_LINKING_ERROR of type: ");
      _13 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (_12, type);
      _14 = std::operator<< <std::char_traits<char> > (_13, "\n");
      _15 = std::operator<< <std::char_traits<char> > (_14, &infoLog);
      _16 = std::operator<< <std::char_traits<char> > (_15, "\n -- --------------------------------------------------- -- ");
      std::basic_ostream<char>::operator<< (_16, endl);
      goto <D.105493>;
      <D.105492>:
      <D.105493>:
      <D.105490>:
    }
  finally
    {
      success = {CLOBBER};
      infoLog = {CLOBBER};
    }
}


std::operator!=<char, std::char_traits<char>, std::allocator<char> > (const struct basic_string & __lhs, const char * __rhs)
{
  bool D.105506;

  _1 = std::operator==<char, std::char_traits<char>, std::allocator<char> > (__lhs, __rhs);
  D.105506 = ~_1;
  return D.105506;
}


std::operator==<char, std::char_traits<char>, std::allocator<char> > (const struct basic_string & __lhs, const char * __rhs)
{
  bool D.105508;

  _1 = std::__cxx11::basic_string<char>::compare (__lhs, __rhs);
  D.105508 = _1 == 0;
  return D.105508;
}


Shader::use (struct Shader * const this)
{
  __glewUseProgram.56_1 = __glewUseProgram;
  _2 = this->ID;
  __glewUseProgram.56_1 (_2);
}


glm::rotate<float, (glm::qualifier)0> (const struct mat & m, float angle, const struct vec & v)
{
  struct vec D.103193;
  struct vec D.103192;
  struct vec D.103188;
  struct vec D.103187;
  struct col_type & D.105511;
  struct vec D.103198;
  struct vec D.103197;
  struct vec D.103196;
  struct vec D.103195;
  struct col_type & D.105512;
  struct vec D.103203;
  struct vec D.103202;
  struct vec D.103201;
  struct vec D.103200;
  struct col_type & D.105513;
  struct col_type & D.105514;
  const float a;
  const float c;
  const float s;
  struct vec axis;
  struct vec temp;
  struct mat Rotate;
  struct mat Result [value-expr: <retval>];

  try
    {
      a = angle;
      c = std::cos (a);
      s = std::sin (a);
      axis = glm::normalize<3, float, (glm::qualifier)0> (v); [return slot optimization]
      _1 = 1.0e+0 - c;
      temp = glm::operator*<float, (glm::qualifier)0> (_1, &axis); [return slot optimization]
      _2 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 0);
      _3 = *_2;
      _4 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
      _5 = *_4;
      _6 = _3 * _5;
      _7 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
      _8 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_7, 0);
      _9 = c + _6;
      *_8 = _9;
      _10 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 0);
      _11 = *_10;
      _12 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
      _13 = *_12;
      _14 = _11 * _13;
      _15 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
      _16 = *_15;
      _17 = s * _16;
      _18 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
      _19 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_18, 1);
      _20 = _14 + _17;
      *_19 = _20;
      _21 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 0);
      _22 = *_21;
      _23 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
      _24 = *_23;
      _25 = _22 * _24;
      _26 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
      _27 = *_26;
      _28 = s * _27;
      _29 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
      _30 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_29, 2);
      _31 = _25 - _28;
      *_30 = _31;
      _32 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 1);
      _33 = *_32;
      _34 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
      _35 = *_34;
      _36 = _33 * _35;
      _37 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
      _38 = *_37;
      _39 = s * _38;
      _40 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
      _41 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_40, 0);
      _42 = _36 - _39;
      *_41 = _42;
      _43 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 1);
      _44 = *_43;
      _45 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
      _46 = *_45;
      _47 = _44 * _46;
      _48 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
      _49 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_48, 1);
      _50 = c + _47;
      *_49 = _50;
      _51 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 1);
      _52 = *_51;
      _53 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
      _54 = *_53;
      _55 = _52 * _54;
      _56 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
      _57 = *_56;
      _58 = s * _57;
      _59 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
      _60 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_59, 2);
      _61 = _55 + _58;
      *_60 = _61;
      _62 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 2);
      _63 = *_62;
      _64 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
      _65 = *_64;
      _66 = _63 * _65;
      _67 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
      _68 = *_67;
      _69 = s * _68;
      _70 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
      _71 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_70, 0);
      _72 = _66 + _69;
      *_71 = _72;
      _73 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 2);
      _74 = *_73;
      _75 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
      _76 = *_75;
      _77 = _74 * _76;
      _78 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
      _79 = *_78;
      _80 = s * _79;
      _81 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
      _82 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_81, 1);
      _83 = _77 - _80;
      *_82 = _83;
      _84 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 2);
      _85 = *_84;
      _86 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
      _87 = *_86;
      _88 = _85 * _87;
      _89 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
      _90 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_89, 2);
      _91 = c + _88;
      *_90 = _91;
      _92 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
      _93 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_92, 2);
      _94 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 2);
      D.103193 = glm::operator*<float, (glm::qualifier)0> (_94, _93); [return slot optimization]
      try
        {
          _95 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
          _96 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_95, 1);
          _97 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 1);
          D.103188 = glm::operator*<float, (glm::qualifier)0> (_97, _96); [return slot optimization]
          try
            {
              _98 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
              _99 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_98, 0);
              _100 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 0);
              D.103187 = glm::operator*<float, (glm::qualifier)0> (_100, _99); [return slot optimization]
              try
                {
                  D.103192 = glm::operator+<float, (glm::qualifier)0> (&D.103187, &D.103188); [return slot optimization]
                  try
                    {
                      D.105511 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 0);
                      *D.105511 = glm::operator+<float, (glm::qualifier)0> (&D.103192, &D.103193);
                    }
                  finally
                    {
                      D.103192 = {CLOBBER};
                    }
                }
              finally
                {
                  D.103187 = {CLOBBER};
                }
            }
          finally
            {
              D.103188 = {CLOBBER};
            }
        }
      finally
        {
          D.103193 = {CLOBBER};
        }
      _101 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
      _102 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_101, 2);
      _103 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 2);
      D.103198 = glm::operator*<float, (glm::qualifier)0> (_103, _102); [return slot optimization]
      try
        {
          _104 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
          _105 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_104, 1);
          _106 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 1);
          D.103196 = glm::operator*<float, (glm::qualifier)0> (_106, _105); [return slot optimization]
          try
            {
              _107 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
              _108 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_107, 0);
              _109 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 0);
              D.103195 = glm::operator*<float, (glm::qualifier)0> (_109, _108); [return slot optimization]
              try
                {
                  D.103197 = glm::operator+<float, (glm::qualifier)0> (&D.103195, &D.103196); [return slot optimization]
                  try
                    {
                      D.105512 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 1);
                      *D.105512 = glm::operator+<float, (glm::qualifier)0> (&D.103197, &D.103198);
                    }
                  finally
                    {
                      D.103197 = {CLOBBER};
                    }
                }
              finally
                {
                  D.103195 = {CLOBBER};
                }
            }
          finally
            {
              D.103196 = {CLOBBER};
            }
        }
      finally
        {
          D.103198 = {CLOBBER};
        }
      _110 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
      _111 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_110, 2);
      _112 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 2);
      D.103203 = glm::operator*<float, (glm::qualifier)0> (_112, _111); [return slot optimization]
      try
        {
          _113 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
          _114 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_113, 1);
          _115 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 1);
          D.103201 = glm::operator*<float, (glm::qualifier)0> (_115, _114); [return slot optimization]
          try
            {
              _116 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
              _117 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_116, 0);
              _118 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 0);
              D.103200 = glm::operator*<float, (glm::qualifier)0> (_118, _117); [return slot optimization]
              try
                {
                  D.103202 = glm::operator+<float, (glm::qualifier)0> (&D.103200, &D.103201); [return slot optimization]
                  try
                    {
                      D.105513 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 2);
                      *D.105513 = glm::operator+<float, (glm::qualifier)0> (&D.103202, &D.103203);
                    }
                  finally
                    {
                      D.103202 = {CLOBBER};
                    }
                }
              finally
                {
                  D.103200 = {CLOBBER};
                }
            }
          finally
            {
              D.103201 = {CLOBBER};
            }
        }
      finally
        {
          D.103203 = {CLOBBER};
        }
      _119 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 3);
      D.105514 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 3);
      *D.105514 = MEM[(const struct vec &)_119];
      return <retval>;
    }
  finally
    {
      axis = {CLOBBER};
      temp = {CLOBBER};
      Rotate = {CLOBBER};
    }
}


std::cos (float __x)
{
  float D.105604;

  D.105604 = __builtin_cosf (__x);
  return D.105604;
}


std::sin (float __x)
{
  float D.105606;

  D.105606 = __builtin_sinf (__x);
  return D.105606;
}


glm::normalize<3, float, (glm::qualifier)0> (const struct vec & x)
{
  <retval> = glm::detail::compute_normalize<3, float, (glm::qualifier)0, false>::call (x); [return slot optimization]
  return <retval>;
}


glm::detail::compute_normalize<3, float, (glm::qualifier)0, false>::call (const struct vec & v)
{
  _1 = glm::dot<3, float, (glm::qualifier)0> (v, v);
  _2 = glm::inversesqrt<float> (_1);
  <retval> = glm::operator*<float, (glm::qualifier)0> (v, _2); [return slot optimization]
  return <retval>;
}


glm::dot<3, float, (glm::qualifier)0> (const struct vec & x, const struct vec & y)
{
  float D.105613;

  D.105613 = glm::detail::compute_dot<glm::vec<3, float, (glm::qualifier)0>, float, false>::call (x, y);
  return D.105613;
}


glm::detail::compute_dot<glm::vec<3, float, (glm::qualifier)0>, float, false>::call (const struct vec & a, const struct vec & b)
{
  float D.105616;
  struct vec tmp;

  try
    {
      tmp = glm::operator*<float, (glm::qualifier)0> (a, b); [return slot optimization]
      _1 = tmp.D.95554.x;
      _2 = tmp.D.95560.y;
      _3 = _1 + _2;
      _4 = tmp.D.95566.z;
      D.105616 = _3 + _4;
      return D.105616;
    }
  finally
    {
      tmp = {CLOBBER};
    }
}


glm::operator*<float, (glm::qualifier)0> (const struct vec & v1, const struct vec & v2)
{
  _1 = v1->D.95566.z;
  _2 = v2->D.95566.z;
  _3 = _1 * _2;
  _4 = v1->D.95560.y;
  _5 = v2->D.95560.y;
  _6 = _4 * _5;
  _7 = v1->D.95554.x;
  _8 = v2->D.95554.x;
  _9 = _7 * _8;
  glm::vec<3, float, (glm::qualifier)0>::vec (&<retval>, _9, _6, _3);
  return <retval>;
}


glm::inversesqrt<float> (float x)
{
  float D.105621;

  _1 = std::sqrt (x);
  D.105621 = 1.0e+0 / _1;
  return D.105621;
}


std::sqrt (float __x)
{
  float D.105623;

  D.105623 = __builtin_sqrtf (__x);
  return D.105623;
}


glm::operator*<float, (glm::qualifier)0> (const struct vec & v, float scalar)
{
  _1 = v->D.95566.z;
  _2 = scalar * _1;
  _3 = v->D.95560.y;
  _4 = scalar * _3;
  _5 = v->D.95554.x;
  _6 = scalar * _5;
  glm::vec<3, float, (glm::qualifier)0>::vec (&<retval>, _6, _4, _2);
  return <retval>;
}


glm::operator*<float, (glm::qualifier)0> (float scalar, const struct vec & v)
{
  _1 = v->D.95566.z;
  _2 = scalar * _1;
  _3 = v->D.95560.y;
  _4 = scalar * _3;
  _5 = v->D.95554.x;
  _6 = scalar * _5;
  glm::vec<3, float, (glm::qualifier)0>::vec (&<retval>, _6, _4, _2);
  return <retval>;
}


glm::vec<3, float, (glm::qualifier)0>::operator[] (struct vec * const this, length_type i)
{
  bool iftmp.57;
  float & D.105635;

  if (i >= 0) goto <D.105634>; else goto <D.105630>;
  <D.105634>:
  _1 = glm::vec<3, float, (glm::qualifier)0>::length ();
  if (i < _1) goto <D.105631>; else goto <D.105630>;
  <D.105630>:
  _assert ("i >= 0 && i < this->length()", "C:/glm/glm/detail/type_vec3.inl", 170);
  if (0 != 0) goto <D.105631>; else goto <D.105632>;
  <D.105631>:
  iftmp.57 = 1;
  goto <D.105633>;
  <D.105632>:
  iftmp.57 = 0;
  <D.105633>:
  switch (i) <default: <D.103181>, case 0: <D.103182>, case 1: <D.103183>, case 2: <D.103184>>
  <D.103181>:
  <D.103182>:
  D.105635 = &this->D.95554.x;
  return D.105635;
  <D.103183>:
  D.105635 = &this->D.95560.y;
  return D.105635;
  <D.103184>:
  D.105635 = &this->D.95566.z;
  return D.105635;
}


glm::vec<3, float, (glm::qualifier)0>::length ()
{
  length_type D.105637;

  D.105637 = 3;
  return D.105637;
}


glm::operator*<float, (glm::qualifier)0> (const struct vec & v, const float & scalar)
{
  struct vec D.53349;

  _1 = *scalar;
  D.53349 = *v;
  try
    {
      _2 = glm::vec<4, float, (glm::qualifier)0>::operator*=<float> (&D.53349, _1);
      <retval> = MEM[(const struct vec &)_2];
      return <retval>;
    }
  finally
    {
      D.53349 = {CLOBBER};
    }
}


glm::vec<4, float, (glm::qualifier)0>::operator*=<float> (struct vec * const this, float scalar)
{
  struct vec & D.105644;
  struct vec D.53360;

  glm::vec<4, float, (glm::qualifier)0>::vec (&D.53360, scalar);
  try
    {
      *this = glm::detail::compute_vec4_mul<float, (glm::qualifier)0, false>::call (this, &D.53360);
      D.105644 = this;
      return D.105644;
    }
  finally
    {
      D.53360 = {CLOBBER};
    }
}


glm::vec<4, float, (glm::qualifier)0>::vec (struct vec * const this, float scalar)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    this->D.51351.x = scalar;
    this->D.51357.y = scalar;
    this->D.51363.z = scalar;
    this->D.51369.w = scalar;
  }
}


glm::detail::compute_vec4_mul<float, (glm::qualifier)0, false>::call (const struct vec & a, const struct vec & b)
{
  _1 = a->D.51369.w;
  _2 = b->D.51369.w;
  _3 = _1 * _2;
  _4 = a->D.51363.z;
  _5 = b->D.51363.z;
  _6 = _4 * _5;
  _7 = a->D.51357.y;
  _8 = b->D.51357.y;
  _9 = _7 * _8;
  _10 = a->D.51351.x;
  _11 = b->D.51351.x;
  _12 = _10 * _11;
  glm::vec<4, float, (glm::qualifier)0>::vec (&<retval>, _12, _9, _6, _3);
  return <retval>;
}


glm::vec<4, float, (glm::qualifier)0>::vec (struct vec * const this, float _x, float _y, float _z, float _w)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    this->D.51351.x = _x;
    this->D.51357.y = _y;
    this->D.51363.z = _z;
    this->D.51369.w = _w;
  }
}


glm::operator+<float, (glm::qualifier)0> (const struct vec & v1, const struct vec & v2)
{
  struct vec D.103213;

  D.103213 = *v1;
  try
    {
      _1 = glm::vec<4, float, (glm::qualifier)0>::operator+=<float> (&D.103213, v2);
      <retval> = MEM[(const struct vec &)_1];
      return <retval>;
    }
  finally
    {
      D.103213 = {CLOBBER};
    }
}


glm::vec<4, float, (glm::qualifier)0>::operator+=<float> (struct vec * const this, const struct vec & v)
{
  struct vec & D.105655;
  struct vec D.103227;

  D.103227 = *v;
  try
    {
      *this = glm::detail::compute_vec4_add<float, (glm::qualifier)0, false>::call (this, &D.103227);
      D.105655 = this;
      return D.105655;
    }
  finally
    {
      D.103227 = {CLOBBER};
    }
}


glm::detail::compute_vec4_add<float, (glm::qualifier)0, false>::call (const struct vec & a, const struct vec & b)
{
  _1 = a->D.51369.w;
  _2 = b->D.51369.w;
  _3 = _1 + _2;
  _4 = a->D.51363.z;
  _5 = b->D.51363.z;
  _6 = _4 + _5;
  _7 = a->D.51357.y;
  _8 = b->D.51357.y;
  _9 = _7 + _8;
  _10 = a->D.51351.x;
  _11 = b->D.51351.x;
  _12 = _10 + _11;
  glm::vec<4, float, (glm::qualifier)0>::vec (&<retval>, _12, _9, _6, _3);
  return <retval>;
}


glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (const struct mat * const this, length_type i)
{
  bool iftmp.58;
  const struct col_type & D.105665;

  _1 = glm::mat<4, 4, float, (glm::qualifier)0>::length ();
  if (i < _1) goto <D.105661>; else goto <D.105664>;
  <D.105664>:
  _assert ("i < this->length()", "C:/glm/glm/detail/type_mat4x4.inl", 298);
  if (0 != 0) goto <D.105661>; else goto <D.105662>;
  <D.105661>:
  iftmp.58 = 1;
  goto <D.105663>;
  <D.105662>:
  iftmp.58 = 0;
  <D.105663>:
  D.105665 = &this->value[i];
  return D.105665;
}


glm::mat<4, 4, float, (glm::qualifier)0>::length ()
{
  length_type D.105667;

  D.105667 = 4;
  return D.105667;
}


glm::vec<3, float, (glm::qualifier)0>::vec (struct vec * const this, float _x, float _y, float _z)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    this->D.95554.x = _x;
    this->D.95560.y = _y;
    this->D.95566.z = _z;
  }
}


glm::translate<float, (glm::qualifier)0> (const struct mat & m, const struct vec & v)
{
  struct vec D.103232;
  struct vec D.103211;
  struct vec D.103210;
  struct vec D.103209;
  struct vec D.103208;
  struct col_type & D.105670;
  struct mat Result [value-expr: <retval>];

  <retval> = *m;
  _1 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 3);
  _2 = glm::vec<3, float, (glm::qualifier)0>::operator[] (v, 2);
  _3 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 2);
  D.103211 = glm::operator*<float, (glm::qualifier)0> (_3, _2); [return slot optimization]
  try
    {
      _4 = glm::vec<3, float, (glm::qualifier)0>::operator[] (v, 1);
      _5 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 1);
      D.103209 = glm::operator*<float, (glm::qualifier)0> (_5, _4); [return slot optimization]
      try
        {
          _6 = glm::vec<3, float, (glm::qualifier)0>::operator[] (v, 0);
          _7 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 0);
          D.103208 = glm::operator*<float, (glm::qualifier)0> (_7, _6); [return slot optimization]
          try
            {
              D.103210 = glm::operator+<float, (glm::qualifier)0> (&D.103208, &D.103209); [return slot optimization]
              try
                {
                  D.103232 = glm::operator+<float, (glm::qualifier)0> (&D.103210, &D.103211); [return slot optimization]
                  try
                    {
                      D.105670 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 3);
                      *D.105670 = glm::operator+<float, (glm::qualifier)0> (&D.103232, _1);
                    }
                  finally
                    {
                      D.103232 = {CLOBBER};
                    }
                }
              finally
                {
                  D.103210 = {CLOBBER};
                }
            }
          finally
            {
              D.103208 = {CLOBBER};
            }
        }
      finally
        {
          D.103209 = {CLOBBER};
        }
    }
  finally
    {
      D.103211 = {CLOBBER};
    }
  return <retval>;
}


glm::vec<3, float, (glm::qualifier)0>::operator[] (const struct vec * const this, length_type i)
{
  bool iftmp.59;
  const float & D.105691;

  if (i >= 0) goto <D.105690>; else goto <D.105686>;
  <D.105690>:
  _1 = glm::vec<3, float, (glm::qualifier)0>::length ();
  if (i < _1) goto <D.105687>; else goto <D.105686>;
  <D.105686>:
  _assert ("i >= 0 && i < this->length()", "C:/glm/glm/detail/type_vec3.inl", 186);
  if (0 != 0) goto <D.105687>; else goto <D.105688>;
  <D.105687>:
  iftmp.59 = 1;
  goto <D.105689>;
  <D.105688>:
  iftmp.59 = 0;
  <D.105689>:
  switch (i) <default: <D.103139>, case 0: <D.103140>, case 1: <D.103141>, case 2: <D.103142>>
  <D.103139>:
  <D.103140>:
  D.105691 = &this->D.95554.x;
  return D.105691;
  <D.103141>:
  D.105691 = &this->D.95560.y;
  return D.105691;
  <D.103142>:
  D.105691 = &this->D.95566.z;
  return D.105691;
}


glm::radians<float> (float degrees)
{
  float D.105693;

  D.105693 = degrees * 1.745329238474369049072265625e-2;
  return D.105693;
}


glm::perspective<float> (float fovy, float aspect, float zNear, float zFar)
{
  <retval> = glm::perspectiveRH_NO<float> (fovy, aspect, zNear, zFar); [return slot optimization]
  return <retval>;
}


glm::perspectiveRH_NO<float> (float fovy, float aspect, float zNear, float zFar)
{
  bool iftmp.60;
  const float tanHalfFovy;
  struct mat Result [value-expr: <retval>];

  try
    {
      _1 = std::numeric_limits<float>::epsilon ();
      _2 = aspect - _1;
      _3 = glm::abs<float> (_2);
      if (_3 > 0.0) goto <D.105699>; else goto <D.105702>;
      <D.105702>:
      _assert ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", "C:/glm/glm/ext/matrix_clip_space.inl", 251);
      if (0 != 0) goto <D.105699>; else goto <D.105700>;
      <D.105699>:
      iftmp.60 = 1;
      goto <D.105701>;
      <D.105700>:
      iftmp.60 = 0;
      <D.105701>:
      _4 = fovy / 2.0e+0;
      _5 = std::tan (_4);
      tanHalfFovy = _5;
      <retval> = {};
      tanHalfFovy.61_6 = tanHalfFovy;
      _7 = aspect * tanHalfFovy.61_6;
      _8 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 0);
      _9 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_8, 0);
      _10 = 1.0e+0 / _7;
      *_9 = _10;
      tanHalfFovy.62_11 = tanHalfFovy;
      _12 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 1);
      _13 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_12, 1);
      _14 = 1.0e+0 / tanHalfFovy.62_11;
      *_13 = _14;
      _15 = zFar + zNear;
      _16 = -_15;
      _17 = zFar - zNear;
      _18 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 2);
      _19 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_18, 2);
      _20 = _16 / _17;
      *_19 = _20;
      _21 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 2);
      _22 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_21, 3);
      *_22 = -1.0e+0;
      _23 = zFar * 2.0e+0;
      _24 = zNear * _23;
      _25 = -_24;
      _26 = zFar - zNear;
      _27 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 3);
      _28 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_27, 2);
      _29 = _25 / _26;
      *_28 = _29;
      return <retval>;
    }
  finally
    {
      tanHalfFovy = {CLOBBER};
    }
}


std::numeric_limits<float>::epsilon ()
{
  float D.105717;

  try
    {
      D.105717 = 1.1920928955078125e-7;
      return D.105717;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


glm::abs<float> (float x)
{
  float D.105719;

  D.105719 = glm::detail::compute_abs<float, true>::call (x);
  return D.105719;
}


glm::detail::compute_abs<float, true>::call (float x)
{
  float D.105721;
  float iftmp.63;

  if (x >= 0.0) goto <D.105723>; else goto <D.105724>;
  <D.105723>:
  iftmp.63 = x;
  goto <D.105725>;
  <D.105724>:
  iftmp.63 = -x;
  <D.105725>:
  D.105721 = iftmp.63;
  return D.105721;
}


std::tan (float __x)
{
  float D.105727;

  D.105727 = __builtin_tanf (__x);
  return D.105727;
}


glm::value_ptr<float, (glm::qualifier)0> (struct mat & m)
{
  float * D.105729;

  _1 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m, 0);
  D.105729 = &_1->D.51351.x;
  return D.105729;
}


glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (struct mat * const this, length_type i)
{
  bool iftmp.64;
  struct col_type & D.105737;

  _1 = glm::mat<4, 4, float, (glm::qualifier)0>::length ();
  if (i < _1) goto <D.105733>; else goto <D.105736>;
  <D.105736>:
  _assert ("i < this->length()", "C:/glm/glm/detail/type_mat4x4.inl", 291);
  if (0 != 0) goto <D.105733>; else goto <D.105734>;
  <D.105733>:
  iftmp.64 = 1;
  goto <D.105735>;
  <D.105734>:
  iftmp.64 = 0;
  <D.105735>:
  D.105737 = &this->value[i];
  return D.105737;
}


glm::vec<4, float, (glm::qualifier)0>::operator[] (struct vec * const this, length_type i)
{
  bool iftmp.65;
  float & D.105745;

  if (i >= 0) goto <D.105744>; else goto <D.105740>;
  <D.105744>:
  _1 = glm::vec<4, float, (glm::qualifier)0>::length ();
  if (i < _1) goto <D.105741>; else goto <D.105740>;
  <D.105740>:
  _assert ("i >= 0 && i < this->length()", "C:/glm/glm/detail/type_vec4.inl", 479);
  if (0 != 0) goto <D.105741>; else goto <D.105742>;
  <D.105741>:
  iftmp.65 = 1;
  goto <D.105743>;
  <D.105742>:
  iftmp.65 = 0;
  <D.105743>:
  switch (i) <default: <D.103245>, case 0: <D.103246>, case 1: <D.103247>, case 2: <D.103248>, case 3: <D.103249>>
  <D.103245>:
  <D.103246>:
  D.105745 = &this->D.51351.x;
  return D.105745;
  <D.103247>:
  D.105745 = &this->D.51357.y;
  return D.105745;
  <D.103248>:
  D.105745 = &this->D.51363.z;
  return D.105745;
  <D.103249>:
  D.105745 = &this->D.51369.w;
  return D.105745;
}


glm::vec<4, float, (glm::qualifier)0>::length ()
{
  length_type D.105747;

  D.105747 = 4;
  return D.105747;
}


std::allocator<char>::allocator (struct allocator * const this)
{
  try
    {
      {
        __gnu_cxx::new_allocator<char>::new_allocator (this);
        try
          {

          }
        catch
          {
            __gnu_cxx::new_allocator<char>::~new_allocator (this);
          }
      }
    }
  catch
    {
      <<<eh_filter (NULL)>>>
        {
          
            _1 = __builtin_eh_pointer (0);
            __cxa_call_unexpected (_1);
          
        }
    }
}


__gnu_cxx::new_allocator<char>::new_allocator (struct new_allocator * const this)
{
  try
    {
      {

      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::basic_string (struct basic_string * const this, const char * __s, const struct allocator & __a)
{
  const char * iftmp.66;

  MEM[(struct  &)this] = {CLOBBER};
  {
    _1 = &this->_M_dataplus;
    _2 = std::__cxx11::basic_string<char>::_M_local_data (this);
    std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _2, __a);
    try
      {
        if (__s != 0B) goto <D.105750>; else goto <D.105751>;
        <D.105750>:
        _3 = std::char_traits<char>::length (__s);
        iftmp.66 = __s + _3;
        goto <D.105752>;
        <D.105751>:
        iftmp.66 = __s + 18446744073709551615;
        <D.105752>:
        std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __s, iftmp.66);
      }
    catch
      {
        _4 = &this->_M_dataplus;
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_4);
      }
  }
}


std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, const struct allocator & __a)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    std::allocator<char>::allocator (this, __a);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


std::char_traits<char>::length (const char_type * __s)
{
  size_t D.105755;

  D.105755 = __builtin_strlen (__s);
  return D.105755;
}


std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end)
{
  struct _Integral D.103459;
  struct __false_type D.105757;
  typedef struct _Integral _Integral;

  try
    {
      std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (this, __beg, __end, D.105757);
    }
  finally
    {
      D.103459 = {CLOBBER};
    }
}


std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct __false_type D.103497)
{
  struct forward_iterator_tag D.104042;
  struct _Tag D.104022;
  struct forward_iterator_tag D.105759;
  typedef struct _Tag _Tag;

  try
    {
      _1 = &D.104022;
      std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __beg, __end, D.105759);
    }
  finally
    {
      D.104022 = {CLOBBER};
    }
}


std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct forward_iterator_tag D.104036)
{
  bool retval.67;
  bool iftmp.68;
  size_type __dnew;

  try
    {
      _1 = __gnu_cxx::__is_null_pointer<const char> (__beg);
      if (_1 != 0) goto <D.105765>; else goto <D.105763>;
      <D.105765>:
      if (__beg != __end) goto <D.105766>; else goto <D.105763>;
      <D.105766>:
      iftmp.68 = 1;
      goto <D.105764>;
      <D.105763>:
      iftmp.68 = 0;
      <D.105764>:
      retval.67 = iftmp.68;
      if (retval.67 != 0) goto <D.105767>; else goto <D.105768>;
      <D.105767>:
      std::__throw_logic_error ("basic_string::_M_construct null not valid");
      <D.105768>:
      _2 = std::distance<const char*> (__beg, __end);
      _3 = (long long unsigned int) _2;
      __dnew = _3;
      __dnew.69_4 = __dnew;
      if (__dnew.69_4 > 15) goto <D.105769>; else goto <D.105770>;
      <D.105769>:
      _5 = std::__cxx11::basic_string<char>::_M_create (this, &__dnew, 0);
      std::__cxx11::basic_string<char>::_M_data (this, _5);
      __dnew.70_6 = __dnew;
      std::__cxx11::basic_string<char>::_M_capacity (this, __dnew.70_6);
      goto <D.105771>;
      <D.105770>:
      <D.105771>:
      try
        {
          _7 = std::__cxx11::basic_string<char>::_M_data (this);
          std::__cxx11::basic_string<char>::_S_copy_chars (_7, __beg, __end);
        }
      catch
        {
          catch (NULL)
            {
              try
                {
                  _8 = __builtin_eh_pointer (0);
                  __cxa_begin_catch (_8);
                  std::__cxx11::basic_string<char>::_M_dispose (this);
                  __cxa_rethrow ();
                }
              finally
                {
                  __cxa_end_catch ();
                }
            }
        }
      __dnew.71_9 = __dnew;
      std::__cxx11::basic_string<char>::_M_set_length (this, __dnew.71_9);
    }
  finally
    {
      __dnew = {CLOBBER};
    }
}


__gnu_cxx::__is_null_pointer<const char> (const char * __ptr)
{
  bool D.105779;

  D.105779 = __ptr == 0B;
  return D.105779;
}


std::distance<const char*> (const char * __first, const char * __last)
{
  difference_type D.105781;
  struct iterator_category D.105182;
  struct random_access_iterator_tag D.105782;

  std::__iterator_category<const char*> (&__first);
  try
    {
      __first.72_1 = __first;
      D.105781 = std::__distance<const char*> (__first.72_1, __last, D.105782);
      return D.105781;
    }
  finally
    {
      D.105182 = {CLOBBER};
    }
}


std::__iterator_category<const char*> (const char * const & D.105181)
{
  struct iterator_category D.105785;

  return D.105785;
}


std::__distance<const char*> (const char * __first, const char * __last, struct random_access_iterator_tag D.105186)
{
  difference_type D.105787;

  D.105787 = __last - __first;
  return D.105787;
}


std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (struct _Alloc_hider * const this)
{
  {
    try
      {
        try
          {

          }
        finally
          {
            std::allocator<char>::~allocator (this);
          }
      }
    finally
      {
        MEM[(struct  &)this] = {CLOBBER};
      }
  }
  <D.102009>:
}


Shader::setMat4 (const struct Shader * const this, const struct string & name, const struct mat4 & mat)
{
  __glewUniformMatrix4fv.73_1 = __glewUniformMatrix4fv;
  _2 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (mat, 0);
  _3 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_2, 0);
  __glewGetUniformLocation.74_4 = __glewGetUniformLocation;
  _5 = std::__cxx11::basic_string<char>::c_str (name);
  _6 = this->ID;
  _7 = __glewGetUniformLocation.74_4 (_6, _5);
  __glewUniformMatrix4fv.73_1 (_7, 1, 0, _3);
}


glm::vec<4, float, (glm::qualifier)0>::operator[] (const struct vec * const this, length_type i)
{
  bool iftmp.75;
  const float & D.105798;

  if (i >= 0) goto <D.105797>; else goto <D.105793>;
  <D.105797>:
  _1 = glm::vec<4, float, (glm::qualifier)0>::length ();
  if (i < _1) goto <D.105794>; else goto <D.105793>;
  <D.105793>:
  _assert ("i >= 0 && i < this->length()", "C:/glm/glm/detail/type_vec4.inl", 497);
  if (0 != 0) goto <D.105794>; else goto <D.105795>;
  <D.105794>:
  iftmp.75 = 1;
  goto <D.105796>;
  <D.105795>:
  iftmp.75 = 0;
  <D.105796>:
  switch (i) <default: <D.103146>, case 0: <D.103147>, case 1: <D.103148>, case 2: <D.103149>, case 3: <D.103150>>
  <D.103146>:
  <D.103147>:
  D.105798 = &this->D.51351.x;
  return D.105798;
  <D.103148>:
  D.105798 = &this->D.51357.y;
  return D.105798;
  <D.103149>:
  D.105798 = &this->D.51363.z;
  return D.105798;
  <D.103150>:
  D.105798 = &this->D.51369.w;
  return D.105798;
}


std::__cxx11::basic_string<char>::~basic_string (struct basic_string * const this)
{
  try
    {
      {
        try
          {
            try
              {
                std::__cxx11::basic_string<char>::_M_dispose (this);
              }
            finally
              {
                _1 = &this->_M_dataplus;
                std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_1);
              }
          }
        finally
          {
            MEM[(struct  &)this] = {CLOBBER};
          }
      }
      <D.102012>:
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::allocator<char>::~allocator (struct allocator * const this)
{
  try
    {
      {
        try
          {

          }
        finally
          {
            __gnu_cxx::new_allocator<char>::~new_allocator (this);
          }
      }
      <D.102615>:
    }
  catch
    {
      <<<eh_filter (NULL)>>>
        {
          
            _1 = __builtin_eh_pointer (0);
            __cxa_call_unexpected (_1);
          
        }
    }
}


__gnu_cxx::new_allocator<char>::~new_allocator (struct new_allocator * const this)
{
  try
    {
      {

      }
      <D.103420>:
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


processInput (struct GLFWwindow * window)
{
  bool retval.76;

  _1 = glfwGetKey (window, 256);
  retval.76 = _1 == 1;
  if (retval.76 != 0) goto <D.105801>; else goto <D.105802>;
  <D.105801>:
  glfwSetWindowShouldClose (window, 1);
  goto <D.105803>;
  <D.105802>:
  <D.105803>:
}


framebuffer_size_callback (struct GLFWwindow * window, int width, int height)
{
  glViewport (0, 0, width, height);
}


__static_initialization_and_destruction_0 (int __initialize_p, int __priority)
{
  if (__initialize_p == 1) goto <D.105805>; else goto <D.105806>;
  <D.105805>:
  if (__priority == 65535) goto <D.105807>; else goto <D.105808>;
  <D.105807>:
  std::ios_base::Init::Init (&__ioinit);
  atexit (__tcf_0);
  goto <D.105809>;
  <D.105808>:
  <D.105809>:
  goto <D.105810>;
  <D.105806>:
  <D.105810>:
}


__tcf_0 ()
{
  std::ios_base::Init::~Init (&__ioinit);
}


_GLOBAL__sub_I_main ()
{
  __static_initialization_and_destruction_0 (1, 65535);
}


