main ()
{
  int D.105370;
  bool retval.0;
  bool retval.1;
  bool retval.3;
  bool retval.16;
  struct vec3 D.100853;
  struct vec3 D.100872;
  const struct string D.100892;
  struct allocator D.100891;

  {
    struct GLFWwindow * window;
    struct Shader ourShader;
    int linhas;
    int i;
    char c;
    char linha[100];
    char * pch;
    struct FILE * arqin;
    float vertices = <<< error >>>;
    <<< error >>> tamVec;
    unsigned int VBO;
    unsigned int VAO;
    float lenVet;

    try
      {
        glfwInit ();
        glfwWindowHint (139266, 3);
        glfwWindowHint (139267, 3);
        glfwWindowHint (139272, 204801);
        window = glfwCreateWindow (800, 600, "OPenGL : Exemplo 3D", 0B, 0B);
        if (window == 0B) goto <D.105368>; else goto <D.105369>;
        <D.105368>:
        _1 = std::operator<< <std::char_traits<char> > (&cout, "Failed to create GLFW window");
        std::basic_ostream<char>::operator<< (_1, endl);
        glfwTerminate ();
        D.105370 = -1;
        // predicted unlikely by early return (on trees) predictor.
        return D.105370;
        <D.105369>:
        glfwMakeContextCurrent (window);
        glfwSetFramebufferSizeCallback (window, framebuffer_size_callback);
        _2 = glewInit ();
        retval.0 = _2 != 0;
        if (retval.0 != 0) goto <D.105372>; else goto <D.105373>;
        <D.105372>:
        _3 = std::operator<< <std::char_traits<char> > (&cout, "Ocorreu um erro iniciando GLEW!");
        std::basic_ostream<char>::operator<< (_3, endl);
        goto <D.105374>;
        <D.105373>:
        _4 = std::operator<< <std::char_traits<char> > (&cout, "GLEW OK!");
        std::basic_ostream<char>::operator<< (_4, endl);
        _5 = glGetString (7938);
        _6 = std::operator<< <std::char_traits<char> > (&cout, _5);
        std::basic_ostream<char>::operator<< (_6, endl);
        <D.105374>:
        glEnable (2929);
        Shader::Shader (&ourShader, "vertex.glsl", "fragment.glsl", 0B);
        linhas = 1;
        i = 0;
        arqin = fopen ("casa.csv", "rt");
        if (arqin == 0B) goto <D.105375>; else goto <D.105376>;
        <D.105375>:
        printf ("Erro na abertura de %s %d\n", "casa.csv", 8);
        exit (0);
        <D.105376>:
        <D.105377>:
        _7 = fread (&c, 1, 1, arqin);
        retval.1 = _7 != 0;
        if (retval.1 != 0) goto <D.105379>; else goto <D.100893>;
        <D.105379>:
        c.2_8 = c;
        if (c.2_8 == 10) goto <D.105380>; else goto <D.105381>;
        <D.105380>:
        linhas = linhas + 1;
        goto <D.105382>;
        <D.105381>:
        <D.105382>:
        goto <D.105377>;
        <D.100893>:
        printf ("Linhas: %d \n", linhas);
        linhas = linhas * 8;
        printf ("Linhas: %d \n", linhas);
        fclose (arqin);
        fopen ("casa.csv", "rt");
        <D.105383>:
        _9 = feof (arqin);
        retval.3 = _9 == 0;
        if (retval.3 != 0) goto <D.105385>; else goto <D.100895>;
        <D.105385>:
        {
          fgets (&linha, 100, arqin);
          pch = strtok (&linha, ";");
          <D.105386>:
          if (pch == 0B) goto <D.100897>; else goto <D.105387>;
          <D.105387>:
          {
            int validarNumerico;

            validarNumerico = strcmp (pch, "\n");
            if (validarNumerico != 0) goto <D.105388>; else goto <D.105389>;
            <D.105388>:
            i = i + 1;
            goto <D.105390>;
            <D.105389>:
            <D.105390>:
            pch = strtok (0B, ";");
          }
          goto <D.105386>;
          <D.100897>:
        }
        goto <D.105383>;
        <D.100895>:
        fclose (arqin);
        i = 0;
        <D.105391>:
        i = i + 1;
        goto <D.105391>;
        <D.100899>:
        __glewGenVertexArrays.4_10 = __glewGenVertexArrays;
        __glewGenVertexArrays.4_10 (1, &VAO);
        __glewGenBuffers.5_11 = __glewGenBuffers;
        __glewGenBuffers.5_11 (1, &VBO);
        __glewBindVertexArray.6_12 = __glewBindVertexArray;
        VAO.7_13 = VAO;
        __glewBindVertexArray.6_12 (VAO.7_13);
        lenVet = 1.0e+0;
        __glewBindBuffer.8_14 = __glewBindBuffer;
        VBO.9_15 = VBO;
        __glewBindBuffer.8_14 (34962, VBO.9_15);
        __glewVertexAttribPointer.10_16 = __glewVertexAttribPointer;
        __glewVertexAttribPointer.10_16 (0, 3, 5126, 0, 32, 0B);
        __glewEnableVertexAttribArray.11_17 = __glewEnableVertexAttribArray;
        __glewEnableVertexAttribArray.11_17 (0);
        __glewVertexAttribPointer.12_18 = __glewVertexAttribPointer;
        __glewVertexAttribPointer.12_18 (1, 3, 5126, 0, 32, 12B);
        __glewEnableVertexAttribArray.13_19 = __glewEnableVertexAttribArray;
        __glewEnableVertexAttribArray.13_19 (1);
        __glewVertexAttribPointer.14_20 = __glewVertexAttribPointer;
        __glewVertexAttribPointer.14_20 (2, 2, 5126, 0, 32, 12B);
        __glewEnableVertexAttribArray.15_21 = __glewEnableVertexAttribArray;
        __glewEnableVertexAttribArray.15_21 (2);
        <D.105392>:
        _22 = glfwWindowShouldClose (window);
        retval.16 = _22 == 0;
        if (retval.16 != 0) goto <D.105394>; else goto <D.100901>;
        <D.105394>:
        {
          struct mat4 model;
          struct mat4 view;
          struct mat4 projection;
          unsigned int modelLoc;
          unsigned int viewLoc;

          try
            {
              processInput (window);
              glClearColor (0.0, 0.0, 0.0, 1.0e+0);
              glClear (16640);
              Shader::use (&ourShader);
              model.value[0].D.51351.x = 1.0e+0;
              model.value[0].D.51357.y = 0.0;
              model.value[0].D.51363.z = 0.0;
              model.value[0].D.51369.w = 0.0;
              model.value[1].D.51351.x = 0.0;
              model.value[1].D.51357.y = 1.0e+0;
              model.value[1].D.51363.z = 0.0;
              model.value[1].D.51369.w = 0.0;
              model.value[2].D.51351.x = 0.0;
              model.value[2].D.51357.y = 0.0;
              model.value[2].D.51363.z = 1.0e+0;
              model.value[2].D.51369.w = 0.0;
              model.value[3].D.51351.x = 0.0;
              model.value[3].D.51357.y = 0.0;
              model.value[3].D.51363.z = 0.0;
              model.value[3].D.51369.w = 1.0e+0;
              view.value[0].D.51351.x = 1.0e+0;
              view.value[0].D.51357.y = 0.0;
              view.value[0].D.51363.z = 0.0;
              view.value[0].D.51369.w = 0.0;
              view.value[1].D.51351.x = 0.0;
              view.value[1].D.51357.y = 1.0e+0;
              view.value[1].D.51363.z = 0.0;
              view.value[1].D.51369.w = 0.0;
              view.value[2].D.51351.x = 0.0;
              view.value[2].D.51357.y = 0.0;
              view.value[2].D.51363.z = 1.0e+0;
              view.value[2].D.51369.w = 0.0;
              view.value[3].D.51351.x = 0.0;
              view.value[3].D.51357.y = 0.0;
              view.value[3].D.51363.z = 0.0;
              view.value[3].D.51369.w = 1.0e+0;
              projection.value[0].D.51351.x = 1.0e+0;
              projection.value[0].D.51357.y = 0.0;
              projection.value[0].D.51363.z = 0.0;
              projection.value[0].D.51369.w = 0.0;
              projection.value[1].D.51351.x = 0.0;
              projection.value[1].D.51357.y = 1.0e+0;
              projection.value[1].D.51363.z = 0.0;
              projection.value[1].D.51369.w = 0.0;
              projection.value[2].D.51351.x = 0.0;
              projection.value[2].D.51357.y = 0.0;
              projection.value[2].D.51363.z = 1.0e+0;
              projection.value[2].D.51369.w = 0.0;
              projection.value[3].D.51351.x = 0.0;
              projection.value[3].D.51357.y = 0.0;
              projection.value[3].D.51363.z = 0.0;
              projection.value[3].D.51369.w = 1.0e+0;
              glm::vec<3, float, (glm::qualifier)0>::vec (&D.100853, 1.0e+0, 0.0, 0.0);
              _23 = glm::radians<float> (5.5e+1);
              model = glm::rotate<float, (glm::qualifier)0> (&model, _23, &D.100853);
              glm::vec<3, float, (glm::qualifier)0>::vec (&D.100872, 0.0, 0.0, -3.0e+0);
              view = glm::translate<float, (glm::qualifier)0> (&view, &D.100872);
              _24 = glm::radians<float> (8.0e+1);
              projection = glm::perspective<float> (_24, 1.33333337306976318359375e+0, 1.00000001490116119384765625e-1, 1.0e+2);
              __glewGetUniformLocation.17_25 = __glewGetUniformLocation;
              _26 = ourShader.ID;
              _27 = __glewGetUniformLocation.17_25 (_26, "model");
              modelLoc = (unsigned int) _27;
              __glewGetUniformLocation.18_28 = __glewGetUniformLocation;
              _29 = ourShader.ID;
              _30 = __glewGetUniformLocation.18_28 (_29, "view");
              viewLoc = (unsigned int) _30;
              __glewUniformMatrix4fv.19_31 = __glewUniformMatrix4fv;
              _32 = glm::value_ptr<float, (glm::qualifier)0> (&model);
              modelLoc.20_33 = (int) modelLoc;
              __glewUniformMatrix4fv.19_31 (modelLoc.20_33, 1, 0, _32);
              __glewUniformMatrix4fv.21_34 = __glewUniformMatrix4fv;
              _35 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&view, 0);
              _36 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_35, 0);
              viewLoc.22_37 = (int) viewLoc;
              __glewUniformMatrix4fv.21_34 (viewLoc.22_37, 1, 0, _36);
              std::allocator<char>::allocator (&D.100891);
              std::__cxx11::basic_string<char>::basic_string (&D.100892, "projection", &D.100891);
              Shader::setMat4 (&ourShader, &D.100892, &projection);
              __glewBindVertexArray.23_38 = __glewBindVertexArray;
              VAO.24_39 = VAO;
              __glewBindVertexArray.23_38 (VAO.24_39);
              glDrawArrays (4, 0, 36);
              glfwSwapBuffers (window);
              glfwPollEvents ();
            }
          finally
            {
              model = {CLOBBER};
              view = {CLOBBER};
              projection = {CLOBBER};
            }
        }
        goto <D.105392>;
        <D.100901>:
        __glewDeleteVertexArrays.25_40 = __glewDeleteVertexArrays;
        __glewDeleteVertexArrays.25_40 (1, &VAO);
        __glewDeleteBuffers.26_41 = __glewDeleteBuffers;
        __glewDeleteBuffers.26_41 (1, &VBO);
        glfwTerminate ();
        D.105370 = 0;
        return D.105370;
      }
    finally
      {
        ourShader = {CLOBBER};
        c = {CLOBBER};
        linha = {CLOBBER};
        VBO = {CLOBBER};
        VAO = {CLOBBER};
      }
  }
  D.105370 = 0;
  return D.105370;
}


Shader::Shader (struct Shader * const this, const char * vertexPath, const char * fragmentPath, const char * geometryPath)
{
  struct __string_type D.95527;
  struct __string_type D.95528;
  struct __string_type D.95530;
  register struct failure * D.95532;
  struct string D.95533;
  struct allocator D.95534;
  struct string D.95535;
  struct allocator D.95536;
  struct string D.95538;
  struct allocator D.95539;
  struct string D.95540;
  struct allocator D.95541;

  MEM[(struct  &)this] = {CLOBBER};
  {
    {
      struct string vertexCode;
      struct string fragmentCode;
      struct string geometryCode;
      struct ifstream vShaderFile;
      struct ifstream fShaderFile;
      struct ifstream gShaderFile;
      const char * vShaderCode;
      const char * fShaderCode;
      unsigned int vertex;
      unsigned int fragment;
      unsigned int geometry;

      try
        {
          std::__cxx11::basic_string<char>::basic_string (&vertexCode);
          try
            {
              std::__cxx11::basic_string<char>::basic_string (&fragmentCode);
              try
                {
                  std::__cxx11::basic_string<char>::basic_string (&geometryCode);
                  try
                    {
                      std::basic_ifstream<char>::basic_ifstream (&vShaderFile);
                      try
                        {
                          std::basic_ifstream<char>::basic_ifstream (&fShaderFile);
                          try
                            {
                              std::basic_ifstream<char>::basic_ifstream (&gShaderFile);
                              try
                                {
                                  _1 = std::operator| (4, 1);
                                  std::basic_ios<char>::exceptions (&vShaderFile.D.92731, _1);
                                  _2 = std::operator| (4, 1);
                                  std::basic_ios<char>::exceptions (&fShaderFile.D.92731, _2);
                                  _3 = std::operator| (4, 1);
                                  std::basic_ios<char>::exceptions (&gShaderFile.D.92731, _3);
                                  try
                                    {
                                      {
                                        struct stringstream vShaderStream;
                                        struct stringstream fShaderStream;

                                        try
                                          {
                                            std::basic_ifstream<char>::open (&vShaderFile, vertexPath, 8);
                                            std::basic_ifstream<char>::open (&fShaderFile, fragmentPath, 8);
                                            _4 = std::operator| (16, 8);
                                            std::__cxx11::basic_stringstream<char>::basic_stringstream (&vShaderStream, _4);
                                            try
                                              {
                                                _5 = std::operator| (16, 8);
                                                std::__cxx11::basic_stringstream<char>::basic_stringstream (&fShaderStream, _5);
                                                try
                                                  {
                                                    _6 = std::basic_ifstream<char>::rdbuf (&vShaderFile);
                                                    std::basic_ostream<char>::operator<< (&vShaderStream.D.94702.D.89313, _6);
                                                    _7 = std::basic_ifstream<char>::rdbuf (&fShaderFile);
                                                    std::basic_ostream<char>::operator<< (&fShaderStream.D.94702.D.89313, _7);
                                                    std::basic_ifstream<char>::close (&vShaderFile);
                                                    std::basic_ifstream<char>::close (&fShaderFile);
                                                    D.95527 = std::__cxx11::basic_stringstream<char>::str (&vShaderStream); [return slot optimization]
                                                    std::__cxx11::basic_string<char>::operator= (&vertexCode, &D.95527);
                                                    D.95528 = std::__cxx11::basic_stringstream<char>::str (&fShaderStream); [return slot optimization]
                                                    std::__cxx11::basic_string<char>::operator= (&fragmentCode, &D.95528);
                                                    {
                                                      if (geometryPath != 0B) goto <D.105415>; else goto <D.105416>;
                                                      <D.105415>:
                                                      {
                                                        struct stringstream gShaderStream;

                                                        try
                                                          {
                                                            std::basic_ifstream<char>::open (&gShaderFile, geometryPath, 8);
                                                            _8 = std::operator| (16, 8);
                                                            std::__cxx11::basic_stringstream<char>::basic_stringstream (&gShaderStream, _8);
                                                            try
                                                              {
                                                                _9 = std::basic_ifstream<char>::rdbuf (&gShaderFile);
                                                                std::basic_ostream<char>::operator<< (&gShaderStream.D.94702.D.89313, _9);
                                                                std::basic_ifstream<char>::close (&gShaderFile);
                                                                D.95530 = std::__cxx11::basic_stringstream<char>::str (&gShaderStream); [return slot optimization]
                                                                std::__cxx11::basic_string<char>::operator= (&geometryCode, &D.95530);
                                                              }
                                                            finally
                                                              {
                                                                std::__cxx11::basic_stringstream<char>::~basic_stringstream (&gShaderStream);
                                                              }
                                                          }
                                                        finally
                                                          {
                                                            gShaderStream = {CLOBBER};
                                                          }
                                                      }
                                                      goto <D.105417>;
                                                      <D.105416>:
                                                      <D.105417>:
                                                    }
                                                  }
                                                finally
                                                  {
                                                    std::__cxx11::basic_stringstream<char>::~basic_stringstream (&fShaderStream);
                                                  }
                                              }
                                            finally
                                              {
                                                std::__cxx11::basic_stringstream<char>::~basic_stringstream (&vShaderStream);
                                              }
                                          }
                                        finally
                                          {
                                            vShaderStream = {CLOBBER};
                                            fShaderStream = {CLOBBER};
                                          }
                                      }
                                    }
                                  catch
                                    {
                                      catch (struct failure)
                                        {
                                          {
                                            struct failure & e;

                                            try
                                              {
                                                _10 = __builtin_eh_pointer (0);
                                                D.95532 = __cxa_begin_catch (_10);
                                                e = D.95532;
                                                _11 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ");
                                                std::basic_ostream<char>::operator<< (_11, endl);
                                              }
                                            finally
                                              {
                                                __cxa_end_catch ();
                                              }
                                          }
                                        }
                                    }
                                  _12 = std::__cxx11::basic_string<char>::c_str (&vertexCode);
                                  vShaderCode = _12;
                                  _13 = std::__cxx11::basic_string<char>::c_str (&fragmentCode);
                                  fShaderCode = _13;
                                  __glewCreateShader.27_14 = __glewCreateShader;
                                  vertex = __glewCreateShader.27_14 (35633);
                                  __glewShaderSource.28_15 = __glewShaderSource;
                                  __glewShaderSource.28_15 (vertex, 1, &vShaderCode, 0B);
                                  __glewCompileShader.29_16 = __glewCompileShader;
                                  __glewCompileShader.29_16 (vertex);
                                  std::allocator<char>::allocator (&D.95534);
                                  std::__cxx11::basic_string<char>::basic_string (&D.95533, "VERTEX", &D.95534);
                                  Shader::checkCompileErrors (this, vertex, &D.95533);
                                  __glewCreateShader.30_17 = __glewCreateShader;
                                  fragment = __glewCreateShader.30_17 (35632);
                                  __glewShaderSource.31_18 = __glewShaderSource;
                                  __glewShaderSource.31_18 (fragment, 1, &fShaderCode, 0B);
                                  __glewCompileShader.32_19 = __glewCompileShader;
                                  __glewCompileShader.32_19 (fragment);
                                  std::allocator<char>::allocator (&D.95536);
                                  std::__cxx11::basic_string<char>::basic_string (&D.95535, "FRAGMENT", &D.95536);
                                  Shader::checkCompileErrors (this, fragment, &D.95535);
                                  {
                                    if (geometryPath != 0B) goto <D.105418>; else goto <D.105419>;
                                    <D.105418>:
                                    {
                                      const char * gShaderCode;

                                      try
                                        {
                                          _20 = std::__cxx11::basic_string<char>::c_str (&geometryCode);
                                          gShaderCode = _20;
                                          __glewCreateShader.33_21 = __glewCreateShader;
                                          geometry = __glewCreateShader.33_21 (36313);
                                          __glewShaderSource.34_22 = __glewShaderSource;
                                          __glewShaderSource.34_22 (geometry, 1, &gShaderCode, 0B);
                                          __glewCompileShader.35_23 = __glewCompileShader;
                                          __glewCompileShader.35_23 (geometry);
                                          std::allocator<char>::allocator (&D.95539);
                                          std::__cxx11::basic_string<char>::basic_string (&D.95538, "GEOMETRY", &D.95539);
                                          Shader::checkCompileErrors (this, geometry, &D.95538);
                                        }
                                      finally
                                        {
                                          gShaderCode = {CLOBBER};
                                        }
                                    }
                                    goto <D.105420>;
                                    <D.105419>:
                                    <D.105420>:
                                  }
                                  __glewCreateProgram.36_24 = __glewCreateProgram;
                                  _25 = __glewCreateProgram.36_24 ();
                                  this->ID = _25;
                                  __glewAttachShader.37_26 = __glewAttachShader;
                                  _27 = this->ID;
                                  __glewAttachShader.37_26 (_27, vertex);
                                  __glewAttachShader.38_28 = __glewAttachShader;
                                  _29 = this->ID;
                                  __glewAttachShader.38_28 (_29, fragment);
                                  if (geometryPath != 0B) goto <D.105421>; else goto <D.105422>;
                                  <D.105421>:
                                  __glewAttachShader.39_30 = __glewAttachShader;
                                  _31 = this->ID;
                                  __glewAttachShader.39_30 (_31, geometry);
                                  goto <D.105423>;
                                  <D.105422>:
                                  <D.105423>:
                                  __glewLinkProgram.40_32 = __glewLinkProgram;
                                  _33 = this->ID;
                                  __glewLinkProgram.40_32 (_33);
                                  std::allocator<char>::allocator (&D.95541);
                                  std::__cxx11::basic_string<char>::basic_string (&D.95540, "PROGRAM", &D.95541);
                                  _34 = this->ID;
                                  Shader::checkCompileErrors (this, _34, &D.95540);
                                  __glewDeleteShader.41_35 = __glewDeleteShader;
                                  __glewDeleteShader.41_35 (vertex);
                                  __glewDeleteShader.42_36 = __glewDeleteShader;
                                  __glewDeleteShader.42_36 (fragment);
                                  if (geometryPath != 0B) goto <D.105424>; else goto <D.105425>;
                                  <D.105424>:
                                  __glewDeleteShader.43_37 = __glewDeleteShader;
                                  __glewDeleteShader.43_37 (geometry);
                                  goto <D.105426>;
                                  <D.105425>:
                                  <D.105426>:
                                }
                              finally
                                {
                                  std::basic_ifstream<char>::~basic_ifstream (&gShaderFile);
                                }
                            }
                          finally
                            {
                              std::basic_ifstream<char>::~basic_ifstream (&fShaderFile);
                            }
                        }
                      finally
                        {
                          std::basic_ifstream<char>::~basic_ifstream (&vShaderFile);
                        }
                    }
                  finally
                    {
                      std::__cxx11::basic_string<char>::~basic_string (&geometryCode);
                    }
                }
              finally
                {
                  std::__cxx11::basic_string<char>::~basic_string (&fragmentCode);
                }
            }
          finally
            {
              std::__cxx11::basic_string<char>::~basic_string (&vertexCode);
            }
        }
      finally
        {
          vertexCode = {CLOBBER};
          fragmentCode = {CLOBBER};
          geometryCode = {CLOBBER};
          vShaderFile = {CLOBBER};
          fShaderFile = {CLOBBER};
          gShaderFile = {CLOBBER};
          vShaderCode = {CLOBBER};
          fShaderCode = {CLOBBER};
        }
    }
  }
}


std::__cxx11::basic_string<char>::basic_string (struct basic_string * const this)
{
  struct allocator D.103063;

  try
    {
      MEM[(struct  &)this] = {CLOBBER};
      {
        _1 = &this->_M_dataplus;
        std::allocator<char>::allocator (&D.103063);
        _2 = std::__cxx11::basic_string<char>::_M_local_data (this);
        std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _2, &D.103063);
        try
          {
            std::__cxx11::basic_string<char>::_M_set_length (this, 0);
          }
        catch
          {
            _3 = &this->_M_dataplus;
            std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_3);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, struct allocator & __a)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    _1 = std::move<std::allocator<char>&> (__a);
    std::allocator<char>::allocator (this, _1);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


std::move<std::allocator<char>&> (struct allocator & __t)
{
  struct type & D.105453;

  try
    {
      D.105453 = __t;
      return D.105453;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::operator| (_Ios_Iostate __a, _Ios_Iostate __b)
{
  _Ios_Iostate D.105455;

  D.105455 = __a | __b;
  return D.105455;
}


std::operator| (_Ios_Openmode __a, _Ios_Openmode __b)
{
  _Ios_Openmode D.105457;

  D.105457 = __a | __b;
  return D.105457;
}


std::allocator<char>::allocator (struct allocator * const this)
{
  try
    {
      {
        __gnu_cxx::new_allocator<char>::new_allocator (this);
        try
          {

          }
        catch
          {
            __gnu_cxx::new_allocator<char>::~new_allocator (this);
          }
      }
    }
  catch
    {
      <<<eh_filter (NULL)>>>
        {
          
            _1 = __builtin_eh_pointer (0);
            __cxa_call_unexpected (_1);
          
        }
    }
}


__gnu_cxx::new_allocator<char>::new_allocator (struct new_allocator * const this)
{
  try
    {
      {

      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


std::__cxx11::basic_string<char>::basic_string (struct basic_string * const this, const char * __s, const struct allocator & __a)
{
  const char * iftmp.44;

  MEM[(struct  &)this] = {CLOBBER};
  {
    _1 = &this->_M_dataplus;
    _2 = std::__cxx11::basic_string<char>::_M_local_data (this);
    std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _2, __a);
    try
      {
        if (__s != 0B) goto <D.105460>; else goto <D.105461>;
        <D.105460>:
        _3 = std::char_traits<char>::length (__s);
        iftmp.44 = __s + _3;
        goto <D.105462>;
        <D.105461>:
        iftmp.44 = __s + 18446744073709551615;
        <D.105462>:
        std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __s, iftmp.44);
      }
    catch
      {
        _4 = &this->_M_dataplus;
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_4);
      }
  }
}


std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, const struct allocator & __a)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    std::allocator<char>::allocator (this, __a);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


std::char_traits<char>::length (const char_type * __s)
{
  size_t D.105465;

  D.105465 = __builtin_strlen (__s);
  return D.105465;
}


std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end)
{
  struct _Integral D.103463;
  struct __false_type D.105467;
  typedef struct _Integral _Integral;

  std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (this, __beg, __end, D.105467);
}


std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct __false_type D.103501)
{
  struct forward_iterator_tag D.104046;
  struct _Tag D.104026;
  struct forward_iterator_tag D.105468;
  typedef struct _Tag _Tag;

  _1 = &D.104026;
  std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __beg, __end, D.105468);
}


std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct forward_iterator_tag D.104040)
{
  bool retval.45;
  bool iftmp.46;
  size_type __dnew;

  try
    {
      _1 = __gnu_cxx::__is_null_pointer<const char> (__beg);
      if (_1 != 0) goto <D.105473>; else goto <D.105471>;
      <D.105473>:
      if (__beg != __end) goto <D.105474>; else goto <D.105471>;
      <D.105474>:
      iftmp.46 = 1;
      goto <D.105472>;
      <D.105471>:
      iftmp.46 = 0;
      <D.105472>:
      retval.45 = iftmp.46;
      if (retval.45 != 0) goto <D.105475>; else goto <D.105476>;
      <D.105475>:
      std::__throw_logic_error ("basic_string::_M_construct null not valid");
      <D.105476>:
      _2 = std::distance<const char*> (__beg, __end);
      _3 = (long long unsigned int) _2;
      __dnew = _3;
      __dnew.47_4 = __dnew;
      if (__dnew.47_4 > 15) goto <D.105477>; else goto <D.105478>;
      <D.105477>:
      _5 = std::__cxx11::basic_string<char>::_M_create (this, &__dnew, 0);
      std::__cxx11::basic_string<char>::_M_data (this, _5);
      __dnew.48_6 = __dnew;
      std::__cxx11::basic_string<char>::_M_capacity (this, __dnew.48_6);
      goto <D.105479>;
      <D.105478>:
      <D.105479>:
      try
        {
          _7 = std::__cxx11::basic_string<char>::_M_data (this);
          std::__cxx11::basic_string<char>::_S_copy_chars (_7, __beg, __end);
        }
      catch
        {
          catch (NULL)
            {
              try
                {
                  _8 = __builtin_eh_pointer (0);
                  __cxa_begin_catch (_8);
                  std::__cxx11::basic_string<char>::_M_dispose (this);
                  __cxa_rethrow ();
                }
              finally
                {
                  __cxa_end_catch ();
                }
            }
        }
      __dnew.49_9 = __dnew;
      std::__cxx11::basic_string<char>::_M_set_length (this, __dnew.49_9);
    }
  finally
    {
      __dnew = {CLOBBER};
    }
}


__gnu_cxx::__is_null_pointer<const char> (const char * __ptr)
{
  bool D.105487;

  D.105487 = __ptr == 0B;
  return D.105487;
}


std::distance<const char*> (const char * __first, const char * __last)
{
  difference_type D.105489;
  struct iterator_category D.105186;
  struct random_access_iterator_tag D.105490;

  std::__iterator_category<const char*> (&__first);
  __first.50_1 = __first;
  D.105489 = std::__distance<const char*> (__first.50_1, __last, D.105490);
  return D.105489;
}


std::__iterator_category<const char*> (const char * const & D.105185)
{
  struct iterator_category D.105492;

  return D.105492;
}


std::__distance<const char*> (const char * __first, const char * __last, struct random_access_iterator_tag D.105190)
{
  difference_type D.105494;

  D.105494 = __last - __first;
  return D.105494;
}


std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (struct _Alloc_hider * const this)
{
  {
    try
      {
        try
          {

          }
        finally
          {
            std::allocator<char>::~allocator (this);
          }
      }
    finally
      {
        MEM[(struct  &)this] = {CLOBBER};
      }
  }
  <D.102013>:
}


Shader::checkCompileErrors (struct Shader * const this, GLuint shader, struct string & restrict type)
{
  bool retval.51;
  GLint success;
  GLchar infoLog[1024];

  try
    {
      retval.51 = std::operator!=<char, std::char_traits<char>, std::allocator<char> > (type, "PROGRAM");
      if (retval.51 != 0) goto <D.105497>; else goto <D.105498>;
      <D.105497>:
      __glewGetShaderiv.52_1 = __glewGetShaderiv;
      __glewGetShaderiv.52_1 (shader, 35713, &success);
      success.53_2 = success;
      if (success.53_2 == 0) goto <D.105499>; else goto <D.105500>;
      <D.105499>:
      __glewGetShaderInfoLog.54_3 = __glewGetShaderInfoLog;
      __glewGetShaderInfoLog.54_3 (shader, 1024, 0B, &infoLog);
      _4 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::SHADER_COMPILATION_ERROR of type: ");
      _5 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (_4, type);
      _6 = std::operator<< <std::char_traits<char> > (_5, "\n");
      _7 = std::operator<< <std::char_traits<char> > (_6, &infoLog);
      _8 = std::operator<< <std::char_traits<char> > (_7, "\n -- --------------------------------------------------- -- ");
      std::basic_ostream<char>::operator<< (_8, endl);
      goto <D.105501>;
      <D.105500>:
      <D.105501>:
      goto <D.105502>;
      <D.105498>:
      __glewGetProgramiv.55_9 = __glewGetProgramiv;
      __glewGetProgramiv.55_9 (shader, 35714, &success);
      success.56_10 = success;
      if (success.56_10 == 0) goto <D.105503>; else goto <D.105504>;
      <D.105503>:
      __glewGetProgramInfoLog.57_11 = __glewGetProgramInfoLog;
      __glewGetProgramInfoLog.57_11 (shader, 1024, 0B, &infoLog);
      _12 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::PROGRAM_LINKING_ERROR of type: ");
      _13 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (_12, type);
      _14 = std::operator<< <std::char_traits<char> > (_13, "\n");
      _15 = std::operator<< <std::char_traits<char> > (_14, &infoLog);
      _16 = std::operator<< <std::char_traits<char> > (_15, "\n -- --------------------------------------------------- -- ");
      std::basic_ostream<char>::operator<< (_16, endl);
      goto <D.105505>;
      <D.105504>:
      <D.105505>:
      <D.105502>:
    }
  finally
    {
      success = {CLOBBER};
      infoLog = {CLOBBER};
    }
}


std::operator!=<char, std::char_traits<char>, std::allocator<char> > (const struct basic_string & __lhs, const char * __rhs)
{
  bool D.105518;

  _1 = std::operator==<char, std::char_traits<char>, std::allocator<char> > (__lhs, __rhs);
  D.105518 = ~_1;
  return D.105518;
}


std::operator==<char, std::char_traits<char>, std::allocator<char> > (const struct basic_string & __lhs, const char * __rhs)
{
  bool D.105520;

  _1 = std::__cxx11::basic_string<char>::compare (__lhs, __rhs);
  D.105520 = _1 == 0;
  return D.105520;
}


std::__cxx11::basic_string<char>::~basic_string (struct basic_string * const this)
{
  try
    {
      {
        try
          {
            try
              {
                std::__cxx11::basic_string<char>::_M_dispose (this);
              }
            finally
              {
                _1 = &this->_M_dataplus;
                std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_1);
              }
          }
        finally
          {
            MEM[(struct  &)this] = {CLOBBER};
          }
      }
      <D.102016>:
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


processInput (struct GLFWwindow * window)
{
  bool retval.58;

  _1 = glfwGetKey (window, 256);
  retval.58 = _1 == 1;
  if (retval.58 != 0) goto <D.105523>; else goto <D.105524>;
  <D.105523>:
  glfwSetWindowShouldClose (window, 1);
  goto <D.105525>;
  <D.105524>:
  <D.105525>:
}


framebuffer_size_callback (struct GLFWwindow * window, int width, int height)
{
  glViewport (0, 0, width, height);
}


__static_initialization_and_destruction_0 (int __initialize_p, int __priority)
{
  if (__initialize_p == 1) goto <D.105527>; else goto <D.105528>;
  <D.105527>:
  if (__priority == 65535) goto <D.105529>; else goto <D.105530>;
  <D.105529>:
  std::ios_base::Init::Init (&__ioinit);
  atexit (__tcf_0);
  goto <D.105531>;
  <D.105530>:
  <D.105531>:
  goto <D.105532>;
  <D.105528>:
  <D.105532>:
}


__tcf_0 ()
{
  std::ios_base::Init::~Init (&__ioinit);
}


_GLOBAL__sub_I_main ()
{
  __static_initialization_and_destruction_0 (1, 65535);
}


