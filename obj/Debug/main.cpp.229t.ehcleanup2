
;; Function std::numeric_limits<float>::epsilon (_ZNSt14numeric_limitsIfE7epsilonEv, funcdef_no=440, decl_uid=28156, cgraph_uid=336, symbol_order=336)

Before removal of unreachable regions:
Eh tree:
   1 must_not_throw
Reachable regions: n_bits = 2, set = {}
Reachable landing pads: n_bits = 1, set = {}
Removing unreachable region 1


After removal of unreachable regions:


std::numeric_limits<float>::epsilon ()
{
  float D.105717;
  float _1;

  <bb 2> :
  _1 = 1.1920928955078125e-7;

  <bb 3> :
<L0>:
  return _1;

}



;; Function glm::vec<4, float, (glm::qualifier)0>::operator*=<float> (_ZN3glm3vecILi4EfLNS_9qualifierE0EEmLIfEERS2_T_, funcdef_no=1544, decl_uid=53350, cgraph_uid=397, symbol_order=397)

Before removal of unreachable regions:
Eh tree:
   2 must_not_throw
   1 cleanup land:{1,<L2>}
Reachable regions: n_bits = 3, set = {}
Reachable landing pads: n_bits = 2, set = {}
Removing unreachable region 1
Removing unreachable region 2


After removal of unreachable regions:


glm::vec<4, float, (glm::qualifier)0>::operator*=<float> (struct vec * const this, float scalar)
{
  struct vec D.53360;
  struct vec & D.105644;
  struct vec & _6;

  <bb 2> :
  glm::vec<4, float, (glm::qualifier)0>::vec (&D.53360, scalar_2(D));
  *this_4(D) = glm::detail::compute_vec4_mul<float, (glm::qualifier)0, false>::call (this_4(D), &D.53360);
  _6 = this_4(D);
  D.53360 ={v} {CLOBBER};

  <bb 3> :
<L1>:
  return _6;

}



;; Function glm::operator*<float, (glm::qualifier)0> (_ZN3glmmlIfLNS_9qualifierE0EEENS_3vecILi4ET_XT0_EEERKS4_RKS3_, funcdef_no=1543, decl_uid=53303, cgraph_uid=398, symbol_order=398)

Before removal of unreachable regions:
Eh tree:
   2 must_not_throw
   1 cleanup land:{1,<L2>}
Reachable regions: n_bits = 3, set = {}
Reachable landing pads: n_bits = 2, set = {}
Removing unreachable region 1
Removing unreachable region 2


After removal of unreachable regions:


glm::operator*<float, (glm::qualifier)0> (const struct vec & v, const float & scalar)
{
  struct vec & D.105641;
  struct vec D.53349;
  float _1;
  struct vec & _2;
  struct vec & _8;

  <bb 2> :
  _1 = *scalar_4(D);
  D.53349 = *v_5(D);
  _8 = glm::vec<4, float, (glm::qualifier)0>::operator*=<float> (&D.53349, _1);
  _2 = _8;
  <retval> = MEM[(const struct vec &)_2];
  D.53349 ={v} {CLOBBER};

  <bb 3> :
<L1>:
  return <retval>;

}



;; Function Shader::Shader (_ZN6ShaderC1EPKcS1_S1_, funcdef_no=3518, decl_uid=95316, cgraph_uid=859, symbol_order=861)

Before removal of unreachable regions:
Eh tree:
   67 must_not_throw
   1 cleanup land:{31,<L44>}
     66 must_not_throw
     2 cleanup land:{30,<L43>}
       65 must_not_throw
       3 cleanup land:{29,<L42>}
         64 must_not_throw
         4 cleanup land:{1,<L41>}
           63 must_not_throw
           5 cleanup land:{2,<L40>}
             62 must_not_throw
             6 cleanup land:{3,<L39>}
               61 must_not_throw
               7 cleanup land:{4,<L38>}
                 60 must_not_throw
                 53 cleanup land:{28,<L37>}
                   59 must_not_throw
                   54 cleanup land:{25,<L36>}
                     58 must_not_throw
                     55 cleanup land:{27,<L35>}
                       57 must_not_throw
                       56 cleanup land:{26,<L34>}
                 52 must_not_throw
                 43 cleanup land:{20,<L33>}
                   51 must_not_throw
                   44 cleanup land:{24,<L32>}
                     50 must_not_throw
                     45 cleanup land:{21,<L31>}
                       49 must_not_throw
                       46 cleanup land:{23,<L30>}
                         48 must_not_throw
                         47 cleanup land:{22,<L29>}
                 42 must_not_throw
                 35 cleanup land:{19,<L28>}
                   41 must_not_throw
                   36 cleanup land:{16,<L27>}
                     40 must_not_throw
                     37 cleanup land:{18,<L26>}
                       39 must_not_throw
                       38 cleanup land:{17,<L25>}
                 34 must_not_throw
                 27 cleanup land:{15,<L24>}
                   33 must_not_throw
                   28 cleanup land:{12,<L23>}
                     32 must_not_throw
                     29 cleanup land:{14,<L22>}
                       31 must_not_throw
                       30 cleanup land:{13,<L21>}
                 26 must_not_throw
                 25 cleanup land:{11,<L20>}
                 8 try land:{10,<L18>} catch:{struct failure}
                   24 must_not_throw
                   9 cleanup land:{5,<L17>}
                     23 must_not_throw
                     10 cleanup land:{6,<L16>}
                       22 must_not_throw
                       11 cleanup land:{7,<L15>}
                         21 must_not_throw
                         16 cleanup land:{8,<L14>}
                           20 must_not_throw
                           17 cleanup land:{9,<L13>}
                             18 cleanup
                               19 cleanup
                         14 cleanup
                           15 cleanup
                         12 cleanup
                           13 cleanup
Reachable regions: n_bits = 68, set = {1 2 3 4 5 6 7 8 9 10 11 16 17 25 27 28 29 
  30 35 36 37 38 43 44 45 46 47 53 54 55 56 }
Reachable landing pads: n_bits = 32, set = {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 
  18 19 20 21 22 23 24 25 26 27 28 29 30 31 }
Removing unreachable region 12
Removing unreachable region 13
Removing unreachable region 14
Removing unreachable region 15
Removing unreachable region 18
Removing unreachable region 19
Removing unreachable region 20
Removing unreachable region 21
Removing unreachable region 22
Removing unreachable region 23
Removing unreachable region 24
Removing unreachable region 26
Removing unreachable region 31
Removing unreachable region 32
Removing unreachable region 33
Removing unreachable region 34
Removing unreachable region 39
Removing unreachable region 40
Removing unreachable region 41
Removing unreachable region 42
Removing unreachable region 48
Removing unreachable region 49
Removing unreachable region 50
Removing unreachable region 51
Removing unreachable region 52
Removing unreachable region 57
Removing unreachable region 58
Removing unreachable region 59
Removing unreachable region 60
Removing unreachable region 61
Removing unreachable region 62
Removing unreachable region 63
Removing unreachable region 64
Removing unreachable region 65
Removing unreachable region 66
Removing unreachable region 67


After removal of unreachable regions:
Eh tree:
   1 cleanup land:{31,<L44>}
     2 cleanup land:{30,<L43>}
       3 cleanup land:{29,<L42>}
         4 cleanup land:{1,<L41>}
           5 cleanup land:{2,<L40>}
             6 cleanup land:{3,<L39>}
               7 cleanup land:{4,<L38>}
                 53 cleanup land:{28,<L37>}
                   54 cleanup land:{25,<L36>}
                     55 cleanup land:{27,<L35>}
                       56 cleanup land:{26,<L34>}
                 43 cleanup land:{20,<L33>}
                   44 cleanup land:{24,<L32>}
                     45 cleanup land:{21,<L31>}
                       46 cleanup land:{23,<L30>}
                         47 cleanup land:{22,<L29>}
                 35 cleanup land:{19,<L28>}
                   36 cleanup land:{16,<L27>}
                     37 cleanup land:{18,<L26>}
                       38 cleanup land:{17,<L25>}
                 27 cleanup land:{15,<L24>}
                   28 cleanup land:{12,<L23>}
                     29 cleanup land:{14,<L22>}
                       30 cleanup land:{13,<L21>}
                 25 cleanup land:{11,<L20>}
                 8 try land:{10,<L18>} catch:{struct failure}
                   9 cleanup land:{5,<L17>}
                     10 cleanup land:{6,<L16>}
                       11 cleanup land:{7,<L15>}
                         16 cleanup land:{8,<L14>}
                           17 cleanup land:{9,<L13>}


Removing basic block 95
Removing basic block 88
Removing basic block 86
Removing basic block 84
Removing basic block 83
Removing basic block 81
Removing basic block 79
Removing basic block 77
Removing basic block 75
Removing basic block 73
Removing basic block 62
Removing unreachable region 1
Removing unreachable region 9
Removing unreachable region 16
Removing unreachable region 27
Removing unreachable region 29
Removing unreachable region 35
Removing unreachable region 37
Removing unreachable region 43
Removing unreachable region 44
Removing unreachable region 46
Removing unreachable region 53
Removing unreachable region 55
Merging blocks 65 and 66
Shader::Shader (struct Shader * const this, const char * vertexPath, const char * fragmentPath, const char * geometryPath)
{
  long long int D.105887;
  unsigned int D.105465;
  unsigned int D.105459;
  unsigned int D.105454;
  unsigned int D.105449;
  struct basic_ostream & D.105444;
  struct __filebuf_type * D.105438;
  struct __filebuf_type * D.105437;
  struct __filebuf_type * D.105436;
  const char * gShaderCode;
  struct failure & e;
  struct stringstream gShaderStream;
  struct stringstream fShaderStream;
  struct stringstream vShaderStream;
  unsigned int geometry;
  unsigned int fragment;
  unsigned int vertex;
  const char * fShaderCode;
  const char * vShaderCode;
  struct ifstream gShaderFile;
  struct ifstream fShaderFile;
  struct ifstream vShaderFile;
  struct string geometryCode;
  struct string fragmentCode;
  struct string vertexCode;
  struct allocator D.95541;
  struct string D.95540;
  struct allocator D.95539;
  struct string D.95538;
  struct allocator D.95536;
  struct string D.95535;
  struct allocator D.95534;
  struct string D.95533;
  register struct failure * D.95532;
  struct __string_type D.95530;
  struct __string_type D.95528;
  struct __string_type D.95527;
  _Ios_Iostate _1;
  _Ios_Iostate _2;
  _Ios_Iostate _3;
  _Ios_Openmode _4;
  _Ios_Openmode _5;
  struct __filebuf_type * _6;
  struct __filebuf_type * _7;
  _Ios_Openmode _8;
  struct __filebuf_type * _9;
  void * _10;
  struct basic_ostream & _11;
  const char * _12;
  const char * _13;
  GLuint (*<T69d>) (GLenum) __glewCreateShader.32_14;
  void (*<T6e6>) (GLuint, GLsizei, const GLchar * const *, const GLint *) __glewShaderSource.33_15;
  void (*<T696>) (GLuint) __glewCompileShader.34_16;
  GLuint (*<T69d>) (GLenum) __glewCreateShader.35_17;
  void (*<T6e6>) (GLuint, GLsizei, const GLchar * const *, const GLint *) __glewShaderSource.36_18;
  void (*<T696>) (GLuint) __glewCompileShader.37_19;
  const char * _20;
  GLuint (*<T69d>) (GLenum) __glewCreateShader.38_21;
  void (*<T6e6>) (GLuint, GLsizei, const GLchar * const *, const GLint *) __glewShaderSource.39_22;
  void (*<T696>) (GLuint) __glewCompileShader.40_23;
  GLuint (*<T699>) (void) __glewCreateProgram.41_24;
  unsigned int _25;
  void (*<T68b>) (GLuint, GLuint) __glewAttachShader.42_26;
  unsigned int _27;
  void (*<T68b>) (GLuint, GLuint) __glewAttachShader.43_28;
  unsigned int _29;
  void (*<T68b>) (GLuint, GLuint) __glewAttachShader.44_30;
  unsigned int _31;
  void (*<T696>) (GLuint) __glewLinkProgram.45_32;
  unsigned int _33;
  unsigned int _34;
  void (*<T696>) (GLuint) __glewDeleteShader.46_35;
  void (*<T696>) (GLuint) __glewDeleteShader.47_36;
  void (*<T696>) (GLuint) __glewDeleteShader.48_37;
  struct __filebuf_type * _83;
  struct __filebuf_type * _86;
  struct __filebuf_type * _103;
  unsigned int _125;
  unsigned int _137;
  unsigned int _152;
  unsigned int _170;
  struct failure * _215;
  struct basic_ostream & _218;

  <bb 2> :
  MEM[(struct  &)this_60(D)] ={v} {CLOBBER};
  std::__cxx11::basic_string<char>::basic_string (&vertexCode);
  std::__cxx11::basic_string<char>::basic_string (&fragmentCode);
  std::__cxx11::basic_string<char>::basic_string (&geometryCode);
  std::basic_ifstream<char>::basic_ifstream (&vShaderFile);

  <bb 3> :
  std::basic_ifstream<char>::basic_ifstream (&fShaderFile);

  <bb 4> :
  std::basic_ifstream<char>::basic_ifstream (&gShaderFile);

  <bb 5> :
  _1 = std::operator| (4, 1);
  std::basic_ios<char>::exceptions (&vShaderFile.D.92731, _1);

  <bb 6> :
  _2 = std::operator| (4, 1);
  std::basic_ios<char>::exceptions (&fShaderFile.D.92731, _2);

  <bb 7> :
  _3 = std::operator| (4, 1);
  std::basic_ios<char>::exceptions (&gShaderFile.D.92731, _3);

  <bb 8> :
  std::basic_ifstream<char>::open (&vShaderFile, vertexPath_74(D), 8);

  <bb 9> :
  std::basic_ifstream<char>::open (&fShaderFile, fragmentPath_76(D), 8);

  <bb 10> :
  _4 = std::operator| (16, 8);
  std::__cxx11::basic_stringstream<char>::basic_stringstream (&vShaderStream, _4);

  <bb 11> :
  _5 = std::operator| (16, 8);
  std::__cxx11::basic_stringstream<char>::basic_stringstream (&fShaderStream, _5);

  <bb 12> :
  _83 = std::basic_ifstream<char>::rdbuf (&vShaderFile);

  <bb 13> :
  _6 = _83;
  std::basic_ostream<char>::operator<< (&vShaderStream.D.94702.D.89313, _6);

  <bb 14> :
  _86 = std::basic_ifstream<char>::rdbuf (&fShaderFile);

  <bb 15> :
  _7 = _86;
  std::basic_ostream<char>::operator<< (&fShaderStream.D.94702.D.89313, _7);

  <bb 16> :
  std::basic_ifstream<char>::close (&vShaderFile);

  <bb 17> :
  std::basic_ifstream<char>::close (&fShaderFile);

  <bb 18> :
  D.95527 = std::__cxx11::basic_stringstream<char>::str (&vShaderStream); [return slot optimization]

  <bb 19> :
  std::__cxx11::basic_string<char>::operator= (&vertexCode, &D.95527);
  std::__cxx11::basic_string<char>::~basic_string (&D.95527);
  D.95527 ={v} {CLOBBER};
  D.95528 = std::__cxx11::basic_stringstream<char>::str (&fShaderStream); [return slot optimization]

  <bb 20> :
  std::__cxx11::basic_string<char>::operator= (&fragmentCode, &D.95528);
  std::__cxx11::basic_string<char>::~basic_string (&D.95528);
  D.95528 ={v} {CLOBBER};
  if (geometryPath_98(D) != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 21> :
  std::basic_ifstream<char>::open (&gShaderFile, geometryPath_98(D), 8);

  <bb 22> :
  _8 = std::operator| (16, 8);
  std::__cxx11::basic_stringstream<char>::basic_stringstream (&gShaderStream, _8);

  <bb 23> :
  _103 = std::basic_ifstream<char>::rdbuf (&gShaderFile);

  <bb 24> :
  _9 = _103;
  std::basic_ostream<char>::operator<< (&gShaderStream.D.94702.D.89313, _9);

  <bb 25> :
  std::basic_ifstream<char>::close (&gShaderFile);

  <bb 26> :
  D.95530 = std::__cxx11::basic_stringstream<char>::str (&gShaderStream); [return slot optimization]

  <bb 27> :
  std::__cxx11::basic_string<char>::operator= (&geometryCode, &D.95530);
  std::__cxx11::basic_string<char>::~basic_string (&D.95530);
  D.95530 ={v} {CLOBBER};
  std::__cxx11::basic_stringstream<char>::~basic_stringstream (&gShaderStream);
  gShaderStream ={v} {CLOBBER};

  <bb 28> :
  std::__cxx11::basic_stringstream<char>::~basic_stringstream (&fShaderStream);
  std::__cxx11::basic_stringstream<char>::~basic_stringstream (&vShaderStream);
  vShaderStream ={v} {CLOBBER};
  fShaderStream ={v} {CLOBBER};

  <bb 29> :
  _12 = std::__cxx11::basic_string<char>::c_str (&vertexCode);
  vShaderCode = _12;
  _13 = std::__cxx11::basic_string<char>::c_str (&fragmentCode);
  fShaderCode = _13;
  __glewCreateShader.32_14 = __glewCreateShader;
  _125 = __glewCreateShader.32_14 (35633);

  <bb 30> :
  vertex_126 = _125;
  __glewShaderSource.33_15 = __glewShaderSource;
  __glewShaderSource.33_15 (vertex_126, 1, &vShaderCode, 0B);

  <bb 31> :
  __glewCompileShader.34_16 = __glewCompileShader;
  __glewCompileShader.34_16 (vertex_126);

  <bb 32> :
  std::allocator<char>::allocator (&D.95534);
  std::__cxx11::basic_string<char>::basic_string (&D.95533, "VERTEX", &D.95534);

  <bb 33> :
  Shader::checkCompileErrors (this_60(D), vertex_126, &D.95533);

  <bb 34> :
  std::__cxx11::basic_string<char>::~basic_string (&D.95533);
  D.95533 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95534);
  D.95534 ={v} {CLOBBER};
  __glewCreateShader.35_17 = __glewCreateShader;
  _137 = __glewCreateShader.35_17 (35632);

  <bb 35> :
  fragment_138 = _137;
  __glewShaderSource.36_18 = __glewShaderSource;
  __glewShaderSource.36_18 (fragment_138, 1, &fShaderCode, 0B);

  <bb 36> :
  __glewCompileShader.37_19 = __glewCompileShader;
  __glewCompileShader.37_19 (fragment_138);

  <bb 37> :
  std::allocator<char>::allocator (&D.95536);
  std::__cxx11::basic_string<char>::basic_string (&D.95535, "FRAGMENT", &D.95536);

  <bb 38> :
  Shader::checkCompileErrors (this_60(D), fragment_138, &D.95535);

  <bb 39> :
  std::__cxx11::basic_string<char>::~basic_string (&D.95535);
  D.95535 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95536);
  D.95536 ={v} {CLOBBER};
  if (geometryPath_98(D) != 0B)
    goto <bb 40>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 40> :
  _20 = std::__cxx11::basic_string<char>::c_str (&geometryCode);
  gShaderCode = _20;
  __glewCreateShader.38_21 = __glewCreateShader;
  _152 = __glewCreateShader.38_21 (36313);

  <bb 41> :
  geometry_153 = _152;
  __glewShaderSource.39_22 = __glewShaderSource;
  __glewShaderSource.39_22 (geometry_153, 1, &gShaderCode, 0B);

  <bb 42> :
  __glewCompileShader.40_23 = __glewCompileShader;
  __glewCompileShader.40_23 (geometry_153);

  <bb 43> :
  std::allocator<char>::allocator (&D.95539);
  std::__cxx11::basic_string<char>::basic_string (&D.95538, "GEOMETRY", &D.95539);

  <bb 44> :
  Shader::checkCompileErrors (this_60(D), geometry_153, &D.95538);

  <bb 45> :
  std::__cxx11::basic_string<char>::~basic_string (&D.95538);
  D.95538 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95539);
  D.95539 ={v} {CLOBBER};
  gShaderCode ={v} {CLOBBER};

  <bb 46> :
  # geometry_38 = PHI <geometry_148(D)(39), geometry_153(45)>
  __glewCreateProgram.41_24 = __glewCreateProgram;
  _170 = __glewCreateProgram.41_24 ();

  <bb 47> :
  _25 = _170;
  this_60(D)->ID = _25;
  __glewAttachShader.42_26 = __glewAttachShader;
  _27 = this_60(D)->ID;
  __glewAttachShader.42_26 (_27, vertex_126);

  <bb 48> :
  __glewAttachShader.43_28 = __glewAttachShader;
  _29 = this_60(D)->ID;
  __glewAttachShader.43_28 (_29, fragment_138);

  <bb 49> :
  if (geometryPath_98(D) != 0B)
    goto <bb 50>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 50> :
  __glewAttachShader.44_30 = __glewAttachShader;
  _31 = this_60(D)->ID;
  __glewAttachShader.44_30 (_31, geometry_38);

  <bb 51> :

  <bb 52> :
  __glewLinkProgram.45_32 = __glewLinkProgram;
  _33 = this_60(D)->ID;
  __glewLinkProgram.45_32 (_33);

  <bb 53> :
  std::allocator<char>::allocator (&D.95541);
  std::__cxx11::basic_string<char>::basic_string (&D.95540, "PROGRAM", &D.95541);

  <bb 54> :
  _34 = this_60(D)->ID;
  Shader::checkCompileErrors (this_60(D), _34, &D.95540);

  <bb 55> :
  std::__cxx11::basic_string<char>::~basic_string (&D.95540);
  D.95540 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95541);
  D.95541 ={v} {CLOBBER};
  __glewDeleteShader.46_35 = __glewDeleteShader;
  __glewDeleteShader.46_35 (vertex_126);

  <bb 56> :
  __glewDeleteShader.47_36 = __glewDeleteShader;
  __glewDeleteShader.47_36 (fragment_138);

  <bb 57> :
  if (geometryPath_98(D) != 0B)
    goto <bb 58>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 58> :
  __glewDeleteShader.48_37 = __glewDeleteShader;
  __glewDeleteShader.48_37 (geometry_38);

  <bb 59> :

  <bb 60> :
  std::basic_ifstream<char>::~basic_ifstream (&gShaderFile);
  std::basic_ifstream<char>::~basic_ifstream (&fShaderFile);
  std::basic_ifstream<char>::~basic_ifstream (&vShaderFile);
  std::__cxx11::basic_string<char>::~basic_string (&geometryCode);
  std::__cxx11::basic_string<char>::~basic_string (&fragmentCode);
  std::__cxx11::basic_string<char>::~basic_string (&vertexCode);
  vertexCode ={v} {CLOBBER};
  fragmentCode ={v} {CLOBBER};
  geometryCode ={v} {CLOBBER};
  vShaderFile ={v} {CLOBBER};
  fShaderFile ={v} {CLOBBER};
  gShaderFile ={v} {CLOBBER};
  vShaderCode ={v} {CLOBBER};
  fShaderCode ={v} {CLOBBER};
  return;

  <bb 61> :
<L13>:
  std::__cxx11::basic_stringstream<char>::~basic_stringstream (&gShaderStream);
  resx 17

  <bb 62> :
<L15>:
  gShaderStream ={v} {CLOBBER};
  std::__cxx11::basic_stringstream<char>::~basic_stringstream (&fShaderStream);
  resx 11

  <bb 63> :
<L16>:
  std::__cxx11::basic_stringstream<char>::~basic_stringstream (&vShaderStream);
  resx 10

  <bb 64> :
<L17>:
  vShaderStream ={v} {CLOBBER};
  fShaderStream ={v} {CLOBBER};
  _236 = __builtin_eh_filter (8);
  if (_236 == 1)
    goto <bb 66>; [INV]
  else
    goto <bb 65>; [INV]

  <bb 65> :
<L45>:
  resx 8

  <bb 66> :
<L19>:
  _10 = __builtin_eh_pointer (8);
  _215 = __cxa_begin_catch (_10);
  e_216 = _215;
  _218 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ");

  <bb 67> :
  _11 = _218;
  std::basic_ostream<char>::operator<< (_11, endl);

  <bb 68> :
  __cxa_end_catch ();
  goto <bb 29>; [INV]

  <bb 69> :
<L20>:
  __cxa_end_catch ();
  resx 25

  <bb 70> :
<L21>:
  std::__cxx11::basic_string<char>::~basic_string (&D.95533);
  resx 30

  <bb 71> :
<L23>:
  D.95533 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95534);
  resx 28

  <bb 72> :
<L25>:
  std::__cxx11::basic_string<char>::~basic_string (&D.95535);
  resx 38

  <bb 73> :
<L27>:
  D.95535 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95536);
  resx 36

  <bb 74> :
<L29>:
  std::__cxx11::basic_string<char>::~basic_string (&D.95538);
  resx 47

  <bb 75> :
<L31>:
  D.95538 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95539);
  resx 45

  <bb 76> :
<L34>:
  std::__cxx11::basic_string<char>::~basic_string (&D.95540);
  resx 56

  <bb 77> :
<L36>:
  D.95540 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.95541);
  resx 54

  <bb 78> :
<L38>:
  D.95541 ={v} {CLOBBER};
  D.95539 ={v} {CLOBBER};
  gShaderCode ={v} {CLOBBER};
  D.95536 ={v} {CLOBBER};
  D.95534 ={v} {CLOBBER};
  std::basic_ifstream<char>::~basic_ifstream (&gShaderFile);
  resx 7

  <bb 79> :
<L39>:
  std::basic_ifstream<char>::~basic_ifstream (&fShaderFile);
  resx 6

  <bb 80> :
<L40>:
  std::basic_ifstream<char>::~basic_ifstream (&vShaderFile);
  resx 5

  <bb 81> :
<L41>:
  std::__cxx11::basic_string<char>::~basic_string (&geometryCode);
  resx 4

  <bb 82> :
<L42>:
  std::__cxx11::basic_string<char>::~basic_string (&fragmentCode);
  resx 3

  <bb 83> :
<L43>:
  std::__cxx11::basic_string<char>::~basic_string (&vertexCode);
  resx 2

}



;; Function Shader::checkCompileErrors (_ZN6Shader18checkCompileErrorsEjNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE, funcdef_no=3538, decl_uid=95314, cgraph_uid=879, symbol_order=881)

Before removal of unreachable regions:
Eh tree:
   2 must_not_throw
   1 cleanup land:{1,<L9>}
Reachable regions: n_bits = 3, set = {1 }
Reachable landing pads: n_bits = 2, set = {1 }
Removing unreachable region 2


After removal of unreachable regions:
Eh tree:
   1 cleanup land:{1,<L9>}


Removing basic block 25
Removing unreachable region 1
Merging blocks 2 and 3
Merging blocks 4 and 5
Merging blocks 6 and 7
Merging blocks 14 and 15
Merging blocks 16 and 17
Merging blocks 6 and 8
Merging blocks 6 and 9
Merging blocks 6 and 10
Merging blocks 6 and 11
Merging blocks 6 and 12
Merging blocks 6 and 13
Merging blocks 16 and 18
Merging blocks 16 and 19
Merging blocks 16 and 20
Merging blocks 16 and 21
Merging blocks 16 and 22
Merging blocks 16 and 23
Shader::checkCompileErrors (struct Shader * const this, GLuint shader, struct string & restrict type)
{
  struct basic_ostream & D.105504;
  struct basic_ostream & D.105503;
  struct basic_ostream & D.105502;
  struct basic_ostream & D.105501;
  struct basic_ostream & D.105500;
  struct basic_ostream & D.105499;
  struct basic_ostream & D.105498;
  struct basic_ostream & D.105497;
  struct basic_ostream & D.105496;
  struct basic_ostream & D.105495;
  bool D.105494;
  GLchar infoLog[1024];
  GLint success;
  bool retval.49;
  void (*<T677>) (GLuint, GLenum, GLint *) __glewGetShaderiv.50_1;
  int success.51_2;
  void (*<T6bf>) (GLuint, GLsizei, GLsizei *, GLchar *) __glewGetShaderInfoLog.52_3;
  struct basic_ostream & _4;
  struct basic_ostream & _5;
  struct basic_ostream & _6;
  struct basic_ostream & _7;
  struct basic_ostream & _8;
  void (*<T677>) (GLuint, GLenum, GLint *) __glewGetProgramiv.53_9;
  int success.54_10;
  void (*<T6bf>) (GLuint, GLsizei, GLsizei *, GLchar *) __glewGetProgramInfoLog.55_11;
  struct basic_ostream & _12;
  struct basic_ostream & _13;
  struct basic_ostream & _14;
  struct basic_ostream & _15;
  struct basic_ostream & _16;
  bool _22;
  bool retval.49_23;
  struct basic_ostream & _28;
  struct basic_ostream & _30;
  struct basic_ostream & _32;
  struct basic_ostream & _34;
  struct basic_ostream & _36;
  struct basic_ostream & _41;
  struct basic_ostream & _43;
  struct basic_ostream & _45;
  struct basic_ostream & _47;
  struct basic_ostream & _49;

  <bb 2> :
  _22 = std::operator!=<char, std::char_traits<char>, std::allocator<char> > (type_20(D), "PROGRAM");
  retval.49_23 = _22;
  if (retval.49_23 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  __glewGetShaderiv.50_1 = __glewGetShaderiv;
  __glewGetShaderiv.50_1 (shader_24(D), 35713, &success);
  success.51_2 = success;
  if (success.51_2 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  __glewGetShaderInfoLog.52_3 = __glewGetShaderInfoLog;
  __glewGetShaderInfoLog.52_3 (shader_24(D), 1024, 0B, &infoLog);
  _28 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::SHADER_COMPILATION_ERROR of type: ");
  _4 = _28;
  _30 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (_4, type_20(D));
  _5 = _30;
  _32 = std::operator<< <std::char_traits<char> > (_5, "\n");
  _6 = _32;
  _34 = std::operator<< <std::char_traits<char> > (_6, &infoLog);
  _7 = _34;
  _36 = std::operator<< <std::char_traits<char> > (_7, "\n -- --------------------------------------------------- -- ");
  _8 = _36;
  std::basic_ostream<char>::operator<< (_8, endl);
  goto <bb 7>; [INV]

  <bb 5> :
  __glewGetProgramiv.53_9 = __glewGetProgramiv;
  __glewGetProgramiv.53_9 (shader_24(D), 35714, &success);
  success.54_10 = success;
  if (success.54_10 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  __glewGetProgramInfoLog.55_11 = __glewGetProgramInfoLog;
  __glewGetProgramInfoLog.55_11 (shader_24(D), 1024, 0B, &infoLog);
  _41 = std::operator<< <std::char_traits<char> > (&cout, "ERROR::PROGRAM_LINKING_ERROR of type: ");
  _12 = _41;
  _43 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (_12, type_20(D));
  _13 = _43;
  _45 = std::operator<< <std::char_traits<char> > (_13, "\n");
  _14 = _45;
  _47 = std::operator<< <std::char_traits<char> > (_14, &infoLog);
  _15 = _47;
  _49 = std::operator<< <std::char_traits<char> > (_15, "\n -- --------------------------------------------------- -- ");
  _16 = _49;
  std::basic_ostream<char>::operator<< (_16, endl);

  <bb 7> :
  success ={v} {CLOBBER};
  infoLog ={v} {CLOBBER};
  return;

}



;; Function main (main, funcdef_no=3539, decl_uid=97940, cgraph_uid=899, symbol_order=903)

Before removal of unreachable regions:
Eh tree:
   16 must_not_throw
   1 cleanup land:{1,<L34>}
     15 must_not_throw
     2 cleanup land:{2,<L33>}
       14 must_not_throw
       7 cleanup land:{8,<L32>}
         13 must_not_throw
         8 cleanup land:{5,<L31>}
           12 must_not_throw
           9 cleanup land:{7,<L30>}
             11 must_not_throw
             10 cleanup land:{6,<L29>}
       6 must_not_throw
       5 cleanup land:{4,<L28>}
       4 must_not_throw
       3 cleanup land:{3,<L27>}
Reachable regions: n_bits = 17, set = {1 2 3 5 7 8 9 10 }
Reachable landing pads: n_bits = 9, set = {1 2 3 4 5 6 7 8 }
Removing unreachable region 4
Removing unreachable region 6
Removing unreachable region 11
Removing unreachable region 12
Removing unreachable region 13
Removing unreachable region 14
Removing unreachable region 15
Removing unreachable region 16


After removal of unreachable regions:
Eh tree:
   1 cleanup land:{1,<L34>}
     2 cleanup land:{2,<L33>}
       7 cleanup land:{8,<L32>}
         8 cleanup land:{5,<L31>}
           9 cleanup land:{7,<L30>}
             10 cleanup land:{6,<L29>}
       5 cleanup land:{4,<L28>}
       3 cleanup land:{3,<L27>}


Removing basic block 95
Removing basic block 94
Removing basic block 93
Removing basic block 91
Removing basic block 89
Removing basic block 88
Removing unreachable region 1
Removing unreachable region 2
Removing unreachable region 3
Removing unreachable region 5
Removing unreachable region 7
Removing unreachable region 9
Merging blocks 2 and 3
Merging blocks 8 and 9
Merging blocks 12 and 13
Merging blocks 16 and 17
Merging blocks 19 and 20
Merging blocks 24 and 25
Merging blocks 28 and 29
Merging blocks 30 and 31
Merging blocks 35 and 36
Merging blocks 39 and 40
Merging blocks 43 and 44
Merging blocks 47 and 48
Merging blocks 59 and 60
Merging blocks 61 and 62
Merging blocks 77 and 78
Merging blocks 82 and 83
Merging blocks 2 and 4
Merging blocks 2 and 5
Merging blocks 2 and 6
Merging blocks 2 and 7
Merging blocks 8 and 10
Merging blocks 8 and 11
Merging blocks 12 and 14
Merging blocks 12 and 15
Merging blocks 16 and 18
Merging blocks 19 and 21
Merging blocks 19 and 22
Merging blocks 19 and 23
Merging blocks 24 and 26
Merging blocks 24 and 27
Merging blocks 35 and 37
Merging blocks 47 and 49
Merging blocks 47 and 50
Merging blocks 47 and 51
Merging blocks 47 and 52
Merging blocks 47 and 53
Merging blocks 47 and 54
Merging blocks 47 and 55
Merging blocks 47 and 56
Merging blocks 47 and 57
Merging blocks 47 and 58
Merging blocks 61 and 63
Merging blocks 61 and 64
Merging blocks 61 and 65
Merging blocks 61 and 66
Merging blocks 61 and 67
Merging blocks 61 and 68
Merging blocks 61 and 69
Merging blocks 61 and 70
Merging blocks 61 and 71
Merging blocks 61 and 72
Merging blocks 61 and 73
Merging blocks 61 and 74
Merging blocks 61 and 75
Merging blocks 77 and 79
Merging blocks 77 and 80
Merging blocks 77 and 81
Merging blocks 82 and 84
Merging blocks 82 and 85
main ()
{
  float & D.105415;
  struct col_type & D.105414;
  float * D.105413;
  int D.105412;
  int D.105411;
  int D.105408;
  long long unsigned int D.105407;
  struct FILE * D.105406;
  struct basic_ostream & D.105405;
  const GLubyte * D.105404;
  struct basic_ostream & D.105403;
  struct basic_ostream & D.105402;
  unsigned int D.105401;
  struct basic_ostream & D.105400;
  struct GLFWwindow * D.105399;
  unsigned int viewLoc;
  unsigned int modelLoc;
  struct mat4 projection;
  struct mat4 view;
  struct mat4 model;
  int validarNumerico;
  unsigned int VAO;
  unsigned int VBO;
  float vertices[0:D.105380] [value-expr: *vertices.3];
  struct FILE * arqin;
  char * pch;
  char linha[100];
  char c;
  int i;
  int linhas;
  struct Shader ourShader;
  struct GLFWwindow * window;
  void * saved_stack.31;
  struct allocator D.100889;
  const struct string D.100890;
  struct vec3 D.100870;
  struct vec3 D.100851;
  bool retval.20;
  bool retval.4;
  float[0:D.105380] * vertices.3;
  sizetype D.105384;
  bitsizetype D.105383;
  sizetype D.105382;
  bitsizetype D.105381;
  sizetype D.105380;
  ssizetype D.105379;
  bool retval.1;
  bool retval.0;
  int D.105366;
  struct basic_ostream & _1;
  unsigned int _2;
  struct basic_ostream & _3;
  struct basic_ostream & _4;
  const GLubyte * _5;
  struct basic_ostream & _6;
  long long unsigned int _7;
  char c.2_8;
  int _9;
  ssizetype _10;
  sizetype _12;
  sizetype _13;
  bitsizetype _14;
  sizetype _16;
  sizetype _17;
  sizetype _19;
  sizetype _20;
  bitsizetype _21;
  sizetype _23;
  sizetype _24;
  int _26;
  double _27;
  float[0:D.105380] * vertices.5_28;
  long long unsigned int _29;
  long long unsigned int _30;
  float * _31;
  float _32;
  float _33;
  double _34;
  void (*<T665>) (GLsizei, GLuint *) __glewGenVertexArrays.6_35;
  void (*<T665>) (GLsizei, GLuint *) __glewGenBuffers.7_36;
  void (*<T696>) (GLuint) __glewBindVertexArray.8_37;
  unsigned int VAO.9_38;
  void (*<T652>) (GLenum, GLuint) __glewBindBuffer.10_39;
  unsigned int VBO.11_40;
  void (*<T658>) (GLenum, GLsizeiptr, const void *, GLenum) __glewBufferData.12_41;
  float[0:D.105380] * vertices.13_42;
  sizetype _43;
  sizetype _44;
  sizetype _45;
  long long int _46;
  void (*<T77f>) (GLuint, GLint, GLenum, GLboolean, GLsizei, const void *) __glewVertexAttribPointer.14_47;
  void (*<T696>) (GLuint) __glewEnableVertexAttribArray.15_48;
  void (*<T77f>) (GLuint, GLint, GLenum, GLboolean, GLsizei, const void *) __glewVertexAttribPointer.16_49;
  void (*<T696>) (GLuint) __glewEnableVertexAttribArray.17_50;
  void (*<T77f>) (GLuint, GLint, GLenum, GLboolean, GLsizei, const void *) __glewVertexAttribPointer.18_51;
  void (*<T696>) (GLuint) __glewEnableVertexAttribArray.19_52;
  int _53;
  float _54;
  float _55;
  GLint (*<T6ba>) (GLuint, const GLchar *) __glewGetUniformLocation.21_56;
  unsigned int _57;
  int _58;
  GLint (*<T6ba>) (GLuint, const GLchar *) __glewGetUniformLocation.22_59;
  unsigned int _60;
  int _61;
  void (*<T71e>) (GLint, GLsizei, GLboolean, const GLfloat *) __glewUniformMatrix4fv.23_62;
  float * _63;
  int modelLoc.24_64;
  void (*<T71e>) (GLint, GLsizei, GLboolean, const GLfloat *) __glewUniformMatrix4fv.25_65;
  struct col_type & _66;
  float & _67;
  int viewLoc.26_68;
  void (*<T696>) (GLuint) __glewBindVertexArray.27_69;
  unsigned int VAO.28_70;
  void (*<T660>) (GLsizei, const GLuint *) __glewDeleteVertexArrays.29_71;
  void (*<T660>) (GLsizei, const GLuint *) __glewDeleteBuffers.30_72;
  int _74;
  void * saved_stack.31_87;
  struct GLFWwindow * _93;
  struct basic_ostream & _96;
  int _99;
  unsigned int _103;
  bool retval.0_104;
  struct basic_ostream & _106;
  struct basic_ostream & _109;
  const GLubyte * _112;
  struct basic_ostream & _114;
  struct FILE * _121;
  long long unsigned int _126;
  bool retval.1_127;
  ssizetype _130;
  bitsizetype _132;
  sizetype _133;
  bitsizetype _134;
  sizetype _135;
  bool retval.4_142;
  int _166;
  bool retval.20_167;
  int _230;
  int _233;
  float * _236;
  struct col_type & _239;
  float & _241;
  int _269;

  <bb 2> :
  saved_stack.31_87 = __builtin_stack_save ();
  glfwInit ();
  glfwWindowHint (139266, 3);
  glfwWindowHint (139267, 3);
  glfwWindowHint (139272, 204801);
  _93 = glfwCreateWindow (800, 600, "OPenGL : TDE 2 - 3D", 0B, 0B);
  window_94 = _93;
  if (window_94 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _96 = std::operator<< <std::char_traits<char> > (&cout, "Failed to create GLFW window");
  _1 = _96;
  std::basic_ostream<char>::operator<< (_1, endl);
  glfwTerminate ();
  _99 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 27>; [INV]

  <bb 4> :
  glfwMakeContextCurrent (window_94);
  glfwSetFramebufferSizeCallback (window_94, framebuffer_size_callback);
  _103 = glewInit ();
  _2 = _103;
  retval.0_104 = _2 != 0;
  if (retval.0_104 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _106 = std::operator<< <std::char_traits<char> > (&cout, "Ocorreu um erro iniciando GLEW!");
  _3 = _106;
  std::basic_ostream<char>::operator<< (_3, endl);
  goto <bb 7>; [INV]

  <bb 6> :
  _109 = std::operator<< <std::char_traits<char> > (&cout, "GLEW OK!");
  _4 = _109;
  std::basic_ostream<char>::operator<< (_4, endl);
  _112 = glGetString (7938);
  _5 = _112;
  _114 = std::operator<< <std::char_traits<char> > (&cout, _5);
  _6 = _114;
  std::basic_ostream<char>::operator<< (_6, endl);

  <bb 7> :
  glEnable (2929);
  Shader::Shader (&ourShader, "vertex.glsl", "fragment.glsl", 0B);
  linhas_118 = 1;
  i_119 = 0;
  _121 = fopen ("casa.csv", "rt");
  arqin_122 = _121;
  if (arqin_122 == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Erro na abertura de %s %d\n", "casa.csv", 8);
  exit (0);

  <bb 9> :
  # linhas_25 = PHI <linhas_118(7), linhas_22(12)>
  _126 = fread (&c, 1, 1, arqin_122);
  _7 = _126;
  retval.1_127 = _7 != 0;
  if (retval.1_127 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  c.2_8 = c;
  if (c.2_8 == 10)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  linhas_128 = linhas_25 + 1;

  <bb 12> :
  # linhas_22 = PHI <linhas_25(10), linhas_128(11)>
  goto <bb 9>; [INV]

  <bb 13> :
  printf ("Linhas: %d \n", linhas_25);
  _9 = linhas_25 * 8;
  _10 = (ssizetype) _9;
  _130 = _10 + -1;
  _131 = (sizetype) _130;
  _12 = (sizetype) _130;
  _13 = _12 + 1;
  _14 = (bitsizetype) _13;
  _132 = _14 * 32;
  _16 = (sizetype) _130;
  _17 = _16 + 1;
  _133 = _17 * 4;
  _19 = (sizetype) _130;
  _20 = _19 + 1;
  _21 = (bitsizetype) _20;
  _134 = _21 * 32;
  _23 = (sizetype) _130;
  _24 = _23 + 1;
  _135 = _24 * 4;
  vertices.3_137 = __builtin_alloca_with_align (_135, 32);
  fclose (arqin_122);
  i_139 = 0;
  fopen ("casa.csv", "rt");

  <bb 14> :
  # i_18 = PHI <i_139(13), i_15(20)>
  _26 = feof (arqin_122);
  retval.4_142 = _26 == 0;
  if (retval.4_142 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 15> :
  fgets (&linha, 100, arqin_122);
  pch_145 = strtok (&linha, ";");

  <bb 16> :
  # i_15 = PHI <i_18(15), i_11(19)>
  # pch_73 = PHI <pch_145(15), pch_152(19)>
  if (pch_73 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  validarNumerico_146 = strcmp (pch_73, "\n");
  if (validarNumerico_146 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  _27 = atof (pch_73);
  vertices.5_28 = vertices.3_137;
  _29 = (long long unsigned int) i_15;
  _30 = _29 * 4;
  _31 = vertices.5_28 + _30;
  _32 = (float) _27;
  *_31 = _32;
  _33 = *vertices.3_137[i_15];
  _34 = (double) _33;
  printf ("vertices[%d]: %f\n ", i_15, _34);
  i_150 = i_15 + 1;

  <bb 19> :
  # i_11 = PHI <i_15(17), i_150(18)>
  pch_152 = strtok (0B, ";");
  goto <bb 16>; [INV]

  <bb 20> :
  goto <bb 14>; [INV]

  <bb 21> :
  fclose (arqin_122);
  __glewGenVertexArrays.6_35 = __glewGenVertexArrays;
  __glewGenVertexArrays.6_35 (1, &VAO);
  __glewGenBuffers.7_36 = __glewGenBuffers;
  __glewGenBuffers.7_36 (1, &VBO);
  __glewBindVertexArray.8_37 = __glewBindVertexArray;
  VAO.9_38 = VAO;
  __glewBindVertexArray.8_37 (VAO.9_38);
  __glewBindBuffer.10_39 = __glewBindBuffer;
  VBO.11_40 = VBO;
  __glewBindBuffer.10_39 (34962, VBO.11_40);
  __glewBufferData.12_41 = __glewBufferData;
  vertices.13_42 = vertices.3_137;
  _43 = (sizetype) _130;
  _44 = _43 + 1;
  _45 = _44 * 4;
  _46 = (long long int) _45;
  __glewBufferData.12_41 (34962, _46, vertices.13_42, 35044);
  __glewVertexAttribPointer.14_47 = __glewVertexAttribPointer;
  __glewVertexAttribPointer.14_47 (0, 3, 5126, 0, 32, 0B);
  __glewEnableVertexAttribArray.15_48 = __glewEnableVertexAttribArray;
  __glewEnableVertexAttribArray.15_48 (0);
  __glewVertexAttribPointer.16_49 = __glewVertexAttribPointer;
  __glewVertexAttribPointer.16_49 (1, 3, 5126, 0, 32, 12B);
  __glewEnableVertexAttribArray.17_50 = __glewEnableVertexAttribArray;
  __glewEnableVertexAttribArray.17_50 (1);
  __glewVertexAttribPointer.18_51 = __glewVertexAttribPointer;
  __glewVertexAttribPointer.18_51 (2, 2, 5126, 0, 32, 12B);
  __glewEnableVertexAttribArray.19_52 = __glewEnableVertexAttribArray;
  __glewEnableVertexAttribArray.19_52 (2);

  <bb 22> :
  _166 = glfwWindowShouldClose (window_94);
  _53 = _166;
  retval.20_167 = _53 == 0;
  if (retval.20_167 != 0)
    goto <bb 23>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 23> :
  processInput (window_94);
  glClearColor (0.0, 0.0, 0.0, 1.0e+0);
  glClear (16640);
  Shader::use (&ourShader);
  model.value[0].D.51351.x = 1.0e+0;
  model.value[0].D.51357.y = 0.0;
  model.value[0].D.51363.z = 0.0;
  model.value[0].D.51369.w = 0.0;
  model.value[1].D.51351.x = 0.0;
  model.value[1].D.51357.y = 1.0e+0;
  model.value[1].D.51363.z = 0.0;
  model.value[1].D.51369.w = 0.0;
  model.value[2].D.51351.x = 0.0;
  model.value[2].D.51357.y = 0.0;
  model.value[2].D.51363.z = 1.0e+0;
  model.value[2].D.51369.w = 0.0;
  model.value[3].D.51351.x = 0.0;
  model.value[3].D.51357.y = 0.0;
  model.value[3].D.51363.z = 0.0;
  model.value[3].D.51369.w = 1.0e+0;
  view.value[0].D.51351.x = 1.0e+0;
  view.value[0].D.51357.y = 0.0;
  view.value[0].D.51363.z = 0.0;
  view.value[0].D.51369.w = 0.0;
  view.value[1].D.51351.x = 0.0;
  view.value[1].D.51357.y = 1.0e+0;
  view.value[1].D.51363.z = 0.0;
  view.value[1].D.51369.w = 0.0;
  view.value[2].D.51351.x = 0.0;
  view.value[2].D.51357.y = 0.0;
  view.value[2].D.51363.z = 1.0e+0;
  view.value[2].D.51369.w = 0.0;
  view.value[3].D.51351.x = 0.0;
  view.value[3].D.51357.y = 0.0;
  view.value[3].D.51363.z = 0.0;
  view.value[3].D.51369.w = 1.0e+0;
  projection.value[0].D.51351.x = 1.0e+0;
  projection.value[0].D.51357.y = 0.0;
  projection.value[0].D.51363.z = 0.0;
  projection.value[0].D.51369.w = 0.0;
  projection.value[1].D.51351.x = 0.0;
  projection.value[1].D.51357.y = 1.0e+0;
  projection.value[1].D.51363.z = 0.0;
  projection.value[1].D.51369.w = 0.0;
  projection.value[2].D.51351.x = 0.0;
  projection.value[2].D.51357.y = 0.0;
  projection.value[2].D.51363.z = 1.0e+0;
  projection.value[2].D.51369.w = 0.0;
  projection.value[3].D.51351.x = 0.0;
  projection.value[3].D.51357.y = 0.0;
  projection.value[3].D.51363.z = 0.0;
  projection.value[3].D.51369.w = 1.0e+0;
  glm::vec<3, float, (glm::qualifier)0>::vec (&D.100851, 1.00000001490116119384765625e-1, 0.0, 0.0);
  _54 = glm::radians<float> (5.5e+1);
  model = glm::rotate<float, (glm::qualifier)0> (&model, _54, &D.100851);
  D.100851 ={v} {CLOBBER};
  glm::vec<3, float, (glm::qualifier)0>::vec (&D.100870, 0.0, 0.0, -3.0e+0);
  view = glm::translate<float, (glm::qualifier)0> (&view, &D.100870);
  D.100870 ={v} {CLOBBER};
  _55 = glm::radians<float> (4.5e+1);
  projection = glm::perspective<float> (_55, 1.33333337306976318359375e+0, 1.00000001490116119384765625e-1, 1.0e+2);
  __glewGetUniformLocation.21_56 = __glewGetUniformLocation;
  _57 = ourShader.ID;
  _230 = __glewGetUniformLocation.21_56 (_57, "model");
  _58 = _230;
  modelLoc_231 = (unsigned int) _58;
  __glewGetUniformLocation.22_59 = __glewGetUniformLocation;
  _60 = ourShader.ID;
  _233 = __glewGetUniformLocation.22_59 (_60, "view");
  _61 = _233;
  viewLoc_234 = (unsigned int) _61;
  __glewUniformMatrix4fv.23_62 = __glewUniformMatrix4fv;
  _236 = glm::value_ptr<float, (glm::qualifier)0> (&model);
  _63 = _236;
  modelLoc.24_64 = (int) modelLoc_231;
  __glewUniformMatrix4fv.23_62 (modelLoc.24_64, 1, 0, _63);
  __glewUniformMatrix4fv.25_65 = __glewUniformMatrix4fv;
  _239 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&view, 0);
  _66 = _239;
  _241 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_66, 0);
  _67 = _241;
  viewLoc.26_68 = (int) viewLoc_234;
  __glewUniformMatrix4fv.25_65 (viewLoc.26_68, 1, 0, _67);
  std::allocator<char>::allocator (&D.100889);
  std::__cxx11::basic_string<char>::basic_string (&D.100890, "projection", &D.100889);

  <bb 24> :
  Shader::setMat4 (&ourShader, &D.100890, &projection);

  <bb 25> :
  std::__cxx11::basic_string<char>::~basic_string (&D.100890);
  D.100890 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.100889);
  D.100889 ={v} {CLOBBER};
  __glewBindVertexArray.27_69 = __glewBindVertexArray;
  VAO.28_70 = VAO;
  __glewBindVertexArray.27_69 (VAO.28_70);
  glDrawArrays (4, 0, 36);
  glfwSwapBuffers (window_94);
  glfwPollEvents ();
  model ={v} {CLOBBER};
  view ={v} {CLOBBER};
  projection ={v} {CLOBBER};
  goto <bb 22>; [INV]

  <bb 26> :
  __glewDeleteVertexArrays.29_71 = __glewDeleteVertexArrays;
  __glewDeleteVertexArrays.29_71 (1, &VAO);
  __glewDeleteBuffers.30_72 = __glewDeleteBuffers;
  __glewDeleteBuffers.30_72 (1, &VBO);
  glfwTerminate ();
  _269 = 0;

  <bb 27> :
  # _74 = PHI <_99(3), _269(26)>
  __builtin_stack_restore (saved_stack.31_87);
  ourShader ={v} {CLOBBER};
  c ={v} {CLOBBER};
  linha ={v} {CLOBBER};
  VBO ={v} {CLOBBER};
  VAO ={v} {CLOBBER};

  <bb 28> :
<L26>:
  return _74;

  <bb 29> :
<L29>:
  std::__cxx11::basic_string<char>::~basic_string (&D.100890);
  resx 10

  <bb 30> :
<L31>:
  D.100890 ={v} {CLOBBER};
  std::allocator<char>::~allocator (&D.100889);
  resx 8

}



;; Function glm::rotate<float, (glm::qualifier)0> (_ZN3glm6rotateIfLNS_9qualifierE0EEENS_3matILi4ELi4ET_XT0_EEERKS4_S3_RKNS_3vecILi3ES3_XT0_EEE, funcdef_no=3904, decl_uid=100852, cgraph_uid=1246, symbol_order=1250)

Before removal of unreachable regions:
Eh tree:
   26 must_not_throw
   1 cleanup land:{1,<L14>}
     25 must_not_throw
     18 cleanup land:{10,<L13>}
       24 must_not_throw
       19 cleanup land:{11,<L12>}
         23 must_not_throw
         20 cleanup land:{12,<L11>}
           22 must_not_throw
           21 cleanup land:{13,<L10>}
     17 must_not_throw
     10 cleanup land:{6,<L9>}
       16 must_not_throw
       11 cleanup land:{7,<L8>}
         15 must_not_throw
         12 cleanup land:{8,<L7>}
           14 must_not_throw
           13 cleanup land:{9,<L6>}
     9 must_not_throw
     2 cleanup land:{2,<L5>}
       8 must_not_throw
       3 cleanup land:{3,<L4>}
         7 must_not_throw
         4 cleanup land:{4,<L3>}
           6 must_not_throw
           5 cleanup land:{5,<L2>}
Reachable regions: n_bits = 27, set = {1 2 3 4 5 10 11 12 13 18 19 20 21 }
Reachable landing pads: n_bits = 14, set = {1 2 3 4 5 6 7 8 9 10 11 12 13 }
Removing unreachable region 6
Removing unreachable region 7
Removing unreachable region 8
Removing unreachable region 9
Removing unreachable region 14
Removing unreachable region 15
Removing unreachable region 16
Removing unreachable region 17
Removing unreachable region 22
Removing unreachable region 23
Removing unreachable region 24
Removing unreachable region 25
Removing unreachable region 26


After removal of unreachable regions:
Eh tree:
   1 cleanup land:{1,<L14>}
     18 cleanup land:{10,<L13>}
       19 cleanup land:{11,<L12>}
         20 cleanup land:{12,<L11>}
           21 cleanup land:{13,<L10>}
     10 cleanup land:{6,<L9>}
       11 cleanup land:{7,<L8>}
         12 cleanup land:{8,<L7>}
           13 cleanup land:{9,<L6>}
     2 cleanup land:{2,<L5>}
       3 cleanup land:{3,<L4>}
         4 cleanup land:{4,<L3>}
           5 cleanup land:{5,<L2>}


Removing basic block 98
Removing basic block 97
Removing basic block 96
Removing basic block 95
Removing basic block 94
Removing basic block 93
Removing basic block 92
Removing basic block 91
Removing basic block 90
Removing basic block 89
Removing basic block 88
Removing basic block 87
Removing basic block 86
Removing unreachable region 1
Removing unreachable region 2
Removing unreachable region 3
Removing unreachable region 4
Removing unreachable region 5
Removing unreachable region 10
Removing unreachable region 11
Removing unreachable region 12
Removing unreachable region 13
Removing unreachable region 18
Removing unreachable region 19
Removing unreachable region 20
Removing unreachable region 21
Merging blocks 2 and 3
Merging blocks 2 and 4
Merging blocks 2 and 5
Merging blocks 2 and 6
Merging blocks 2 and 7
Merging blocks 2 and 8
Merging blocks 2 and 9
Merging blocks 2 and 10
Merging blocks 2 and 11
Merging blocks 2 and 12
Merging blocks 2 and 13
Merging blocks 2 and 14
Merging blocks 2 and 15
Merging blocks 2 and 16
Merging blocks 2 and 17
Merging blocks 2 and 18
Merging blocks 2 and 19
Merging blocks 2 and 20
Merging blocks 2 and 21
Merging blocks 2 and 22
Merging blocks 2 and 23
Merging blocks 2 and 24
Merging blocks 2 and 25
Merging blocks 2 and 26
Merging blocks 2 and 27
Merging blocks 2 and 28
Merging blocks 2 and 29
Merging blocks 2 and 30
Merging blocks 2 and 31
Merging blocks 2 and 32
Merging blocks 2 and 33
Merging blocks 2 and 34
Merging blocks 2 and 35
Merging blocks 2 and 36
Merging blocks 2 and 37
Merging blocks 2 and 38
Merging blocks 2 and 39
Merging blocks 2 and 40
Merging blocks 2 and 41
Merging blocks 2 and 42
Merging blocks 2 and 43
Merging blocks 2 and 44
Merging blocks 2 and 45
Merging blocks 2 and 46
Merging blocks 2 and 47
Merging blocks 2 and 48
Merging blocks 2 and 49
Merging blocks 2 and 50
Merging blocks 2 and 51
Merging blocks 2 and 52
Merging blocks 2 and 53
Merging blocks 2 and 54
Merging blocks 2 and 55
Merging blocks 2 and 56
Merging blocks 2 and 57
Merging blocks 2 and 58
Merging blocks 2 and 59
Merging blocks 2 and 60
Merging blocks 2 and 61
Merging blocks 2 and 62
Merging blocks 2 and 63
Merging blocks 2 and 64
Merging blocks 2 and 65
Merging blocks 2 and 66
Merging blocks 2 and 67
Merging blocks 2 and 68
Merging blocks 2 and 69
Merging blocks 2 and 70
Merging blocks 2 and 71
Merging blocks 2 and 72
Merging blocks 2 and 73
Merging blocks 2 and 74
Merging blocks 2 and 75
Merging blocks 2 and 76
Merging blocks 2 and 77
Merging blocks 2 and 78
Merging blocks 2 and 79
Merging blocks 2 and 80
Merging blocks 2 and 81
Merging blocks 2 and 82
Merging blocks 2 and 83
glm::rotate<float, (glm::qualifier)0> (const struct mat & m, float angle, const struct vec & v)
{
  struct col_type & D.105601;
  const struct col_type & D.105600;
  struct col_type & D.105595;
  const struct col_type & D.105594;
  float & D.105593;
  struct col_type & D.105592;
  const struct col_type & D.105591;
  float & D.105590;
  struct col_type & D.105589;
  const struct col_type & D.105588;
  float & D.105587;
  struct col_type & D.105586;
  struct col_type & D.105581;
  const struct col_type & D.105580;
  float & D.105579;
  struct col_type & D.105578;
  const struct col_type & D.105577;
  float & D.105576;
  struct col_type & D.105575;
  const struct col_type & D.105574;
  float & D.105573;
  struct col_type & D.105572;
  struct col_type & D.105567;
  const struct col_type & D.105566;
  float & D.105565;
  struct col_type & D.105564;
  const struct col_type & D.105563;
  float & D.105562;
  struct col_type & D.105561;
  const struct col_type & D.105560;
  float & D.105559;
  struct col_type & D.105558;
  float & D.105557;
  struct col_type & D.105556;
  float & D.105555;
  float & D.105554;
  float & D.105553;
  struct col_type & D.105552;
  float & D.105551;
  float & D.105550;
  float & D.105549;
  float & D.105548;
  struct col_type & D.105547;
  float & D.105546;
  float & D.105545;
  float & D.105544;
  float & D.105543;
  struct col_type & D.105542;
  float & D.105541;
  float & D.105540;
  float & D.105539;
  float & D.105538;
  struct col_type & D.105537;
  float & D.105536;
  float & D.105535;
  float & D.105534;
  struct col_type & D.105533;
  float & D.105532;
  float & D.105531;
  float & D.105530;
  float & D.105529;
  struct col_type & D.105528;
  float & D.105527;
  float & D.105526;
  float & D.105525;
  float & D.105524;
  struct col_type & D.105523;
  float & D.105522;
  float & D.105521;
  float & D.105520;
  float & D.105519;
  struct col_type & D.105518;
  float & D.105517;
  float & D.105516;
  struct mat Result [value-expr: <retval>];
  struct mat Rotate;
  struct vec temp;
  struct vec axis;
  const float s;
  const float c;
  const float a;
  struct col_type & D.105514;
  struct col_type & D.105513;
  struct vec D.103200;
  struct vec D.103201;
  struct vec D.103202;
  struct vec D.103203;
  struct col_type & D.105512;
  struct vec D.103195;
  struct vec D.103196;
  struct vec D.103197;
  struct vec D.103198;
  struct col_type & D.105511;
  struct vec D.103187;
  struct vec D.103188;
  struct vec D.103192;
  struct vec D.103193;
  float _1;
  float & _2;
  float _3;
  float & _4;
  float _5;
  float _6;
  struct col_type & _7;
  float & _8;
  float _9;
  float & _10;
  float _11;
  float & _12;
  float _13;
  float _14;
  float & _15;
  float _16;
  float _17;
  struct col_type & _18;
  float & _19;
  float _20;
  float & _21;
  float _22;
  float & _23;
  float _24;
  float _25;
  float & _26;
  float _27;
  float _28;
  struct col_type & _29;
  float & _30;
  float _31;
  float & _32;
  float _33;
  float & _34;
  float _35;
  float _36;
  float & _37;
  float _38;
  float _39;
  struct col_type & _40;
  float & _41;
  float _42;
  float & _43;
  float _44;
  float & _45;
  float _46;
  float _47;
  struct col_type & _48;
  float & _49;
  float _50;
  float & _51;
  float _52;
  float & _53;
  float _54;
  float _55;
  float & _56;
  float _57;
  float _58;
  struct col_type & _59;
  float & _60;
  float _61;
  float & _62;
  float _63;
  float & _64;
  float _65;
  float _66;
  float & _67;
  float _68;
  float _69;
  struct col_type & _70;
  float & _71;
  float _72;
  float & _73;
  float _74;
  float & _75;
  float _76;
  float _77;
  float & _78;
  float _79;
  float _80;
  struct col_type & _81;
  float & _82;
  float _83;
  float & _84;
  float _85;
  float & _86;
  float _87;
  float _88;
  struct col_type & _89;
  float & _90;
  float _91;
  struct col_type & _92;
  float & _93;
  const struct col_type & _94;
  struct col_type & _95;
  float & _96;
  const struct col_type & _97;
  struct col_type & _98;
  float & _99;
  const struct col_type & _100;
  struct col_type & _101;
  float & _102;
  const struct col_type & _103;
  struct col_type & _104;
  float & _105;
  const struct col_type & _106;
  struct col_type & _107;
  float & _108;
  const struct col_type & _109;
  struct col_type & _110;
  float & _111;
  const struct col_type & _112;
  struct col_type & _113;
  float & _114;
  const struct col_type & _115;
  struct col_type & _116;
  float & _117;
  const struct col_type & _118;
  const struct col_type & _119;
  float & _144;
  float & _146;
  struct col_type & _148;
  float & _150;
  float & _153;
  float & _155;
  float & _157;
  struct col_type & _159;
  float & _161;
  float & _164;
  float & _166;
  float & _168;
  struct col_type & _170;
  float & _172;
  float & _175;
  float & _177;
  float & _179;
  struct col_type & _181;
  float & _183;
  float & _186;
  float & _188;
  struct col_type & _190;
  float & _192;
  float & _195;
  float & _197;
  float & _199;
  struct col_type & _201;
  float & _203;
  float & _206;
  float & _208;
  float & _210;
  struct col_type & _212;
  float & _214;
  float & _217;
  float & _219;
  float & _221;
  struct col_type & _223;
  float & _225;
  float & _228;
  float & _230;
  struct col_type & _232;
  float & _234;
  struct col_type & _237;
  float & _239;
  const struct col_type & _242;
  struct col_type & _245;
  float & _247;
  const struct col_type & _249;
  struct col_type & _252;
  float & _254;
  const struct col_type & _256;
  struct col_type & _260;
  struct col_type & _261;
  struct col_type & _268;
  float & _270;
  const struct col_type & _272;
  struct col_type & _275;
  float & _277;
  const struct col_type & _279;
  struct col_type & _282;
  float & _284;
  const struct col_type & _286;
  struct col_type & _290;
  struct col_type & _291;
  struct col_type & _298;
  float & _300;
  const struct col_type & _302;
  struct col_type & _305;
  float & _307;
  const struct col_type & _309;
  struct col_type & _312;
  float & _314;
  const struct col_type & _316;
  struct col_type & _320;
  struct col_type & _321;
  const struct col_type & _328;
  struct col_type & _330;
  struct col_type & _331;

  <bb 2> :
  a_134 = angle_133(D);
  c_137 = std::cos (a_134);
  s_139 = std::sin (a_134);
  axis = glm::normalize<3, float, (glm::qualifier)0> (v_140(D)); [return slot optimization]
  _1 = 1.0e+0 - c_137;
  temp = glm::operator*<float, (glm::qualifier)0> (_1, &axis); [return slot optimization]
  _144 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 0);
  _2 = _144;
  _3 = *_2;
  _146 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
  _4 = _146;
  _5 = *_4;
  _6 = _3 * _5;
  _148 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
  _7 = _148;
  _150 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_7, 0);
  _8 = _150;
  _9 = c_137 + _6;
  *_8 = _9;
  _153 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 0);
  _10 = _153;
  _11 = *_10;
  _155 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
  _12 = _155;
  _13 = *_12;
  _14 = _11 * _13;
  _157 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
  _15 = _157;
  _16 = *_15;
  _17 = s_139 * _16;
  _159 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
  _18 = _159;
  _161 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_18, 1);
  _19 = _161;
  _20 = _14 + _17;
  *_19 = _20;
  _164 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 0);
  _21 = _164;
  _22 = *_21;
  _166 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
  _23 = _166;
  _24 = *_23;
  _25 = _22 * _24;
  _168 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
  _26 = _168;
  _27 = *_26;
  _28 = s_139 * _27;
  _170 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
  _29 = _170;
  _172 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_29, 2);
  _30 = _172;
  _31 = _25 - _28;
  *_30 = _31;
  _175 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 1);
  _32 = _175;
  _33 = *_32;
  _177 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
  _34 = _177;
  _35 = *_34;
  _36 = _33 * _35;
  _179 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
  _37 = _179;
  _38 = *_37;
  _39 = s_139 * _38;
  _181 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
  _40 = _181;
  _183 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_40, 0);
  _41 = _183;
  _42 = _36 - _39;
  *_41 = _42;
  _186 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 1);
  _43 = _186;
  _44 = *_43;
  _188 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
  _45 = _188;
  _46 = *_45;
  _47 = _44 * _46;
  _190 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
  _48 = _190;
  _192 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_48, 1);
  _49 = _192;
  _50 = c_137 + _47;
  *_49 = _50;
  _195 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 1);
  _51 = _195;
  _52 = *_51;
  _197 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
  _53 = _197;
  _54 = *_53;
  _55 = _52 * _54;
  _199 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
  _56 = _199;
  _57 = *_56;
  _58 = s_139 * _57;
  _201 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
  _59 = _201;
  _203 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_59, 2);
  _60 = _203;
  _61 = _55 + _58;
  *_60 = _61;
  _206 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 2);
  _62 = _206;
  _63 = *_62;
  _208 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
  _64 = _208;
  _65 = *_64;
  _66 = _63 * _65;
  _210 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
  _67 = _210;
  _68 = *_67;
  _69 = s_139 * _68;
  _212 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
  _70 = _212;
  _214 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_70, 0);
  _71 = _214;
  _72 = _66 + _69;
  *_71 = _72;
  _217 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 2);
  _73 = _217;
  _74 = *_73;
  _219 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 1);
  _75 = _219;
  _76 = *_75;
  _77 = _74 * _76;
  _221 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 0);
  _78 = _221;
  _79 = *_78;
  _80 = s_139 * _79;
  _223 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
  _81 = _223;
  _225 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_81, 1);
  _82 = _225;
  _83 = _77 - _80;
  *_82 = _83;
  _228 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&temp, 2);
  _84 = _228;
  _85 = *_84;
  _230 = glm::vec<3, float, (glm::qualifier)0>::operator[] (&axis, 2);
  _86 = _230;
  _87 = *_86;
  _88 = _85 * _87;
  _232 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
  _89 = _232;
  _234 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_89, 2);
  _90 = _234;
  _91 = c_137 + _88;
  *_90 = _91;
  _237 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
  _92 = _237;
  _239 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_92, 2);
  _93 = _239;
  _242 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 2);
  _94 = _242;
  D.103193 = glm::operator*<float, (glm::qualifier)0> (_94, _93); [return slot optimization]
  _245 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
  _95 = _245;
  _247 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_95, 1);
  _96 = _247;
  _249 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 1);
  _97 = _249;
  D.103188 = glm::operator*<float, (glm::qualifier)0> (_97, _96); [return slot optimization]
  _252 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 0);
  _98 = _252;
  _254 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_98, 0);
  _99 = _254;
  _256 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 0);
  _100 = _256;
  D.103187 = glm::operator*<float, (glm::qualifier)0> (_100, _99); [return slot optimization]
  D.103192 = glm::operator+<float, (glm::qualifier)0> (&D.103187, &D.103188); [return slot optimization]
  _260 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 0);
  _261 = _260;
  *_261 = glm::operator+<float, (glm::qualifier)0> (&D.103192, &D.103193);
  D.103192 ={v} {CLOBBER};
  D.103187 ={v} {CLOBBER};
  D.103188 ={v} {CLOBBER};
  D.103193 ={v} {CLOBBER};
  _268 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
  _101 = _268;
  _270 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_101, 2);
  _102 = _270;
  _272 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 2);
  _103 = _272;
  D.103198 = glm::operator*<float, (glm::qualifier)0> (_103, _102); [return slot optimization]
  _275 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
  _104 = _275;
  _277 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_104, 1);
  _105 = _277;
  _279 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 1);
  _106 = _279;
  D.103196 = glm::operator*<float, (glm::qualifier)0> (_106, _105); [return slot optimization]
  _282 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 1);
  _107 = _282;
  _284 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_107, 0);
  _108 = _284;
  _286 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 0);
  _109 = _286;
  D.103195 = glm::operator*<float, (glm::qualifier)0> (_109, _108); [return slot optimization]
  D.103197 = glm::operator+<float, (glm::qualifier)0> (&D.103195, &D.103196); [return slot optimization]
  _290 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 1);
  _291 = _290;
  *_291 = glm::operator+<float, (glm::qualifier)0> (&D.103197, &D.103198);
  D.103197 ={v} {CLOBBER};
  D.103195 ={v} {CLOBBER};
  D.103196 ={v} {CLOBBER};
  D.103198 ={v} {CLOBBER};
  _298 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
  _110 = _298;
  _300 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_110, 2);
  _111 = _300;
  _302 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 2);
  _112 = _302;
  D.103203 = glm::operator*<float, (glm::qualifier)0> (_112, _111); [return slot optimization]
  _305 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
  _113 = _305;
  _307 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_113, 1);
  _114 = _307;
  _309 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 1);
  _115 = _309;
  D.103201 = glm::operator*<float, (glm::qualifier)0> (_115, _114); [return slot optimization]
  _312 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&Rotate, 2);
  _116 = _312;
  _314 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_116, 0);
  _117 = _314;
  _316 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 0);
  _118 = _316;
  D.103200 = glm::operator*<float, (glm::qualifier)0> (_118, _117); [return slot optimization]
  D.103202 = glm::operator+<float, (glm::qualifier)0> (&D.103200, &D.103201); [return slot optimization]
  _320 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 2);
  _321 = _320;
  *_321 = glm::operator+<float, (glm::qualifier)0> (&D.103202, &D.103203);
  D.103202 ={v} {CLOBBER};
  D.103200 ={v} {CLOBBER};
  D.103201 ={v} {CLOBBER};
  D.103203 ={v} {CLOBBER};
  _328 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_240(D), 3);
  _119 = _328;
  _330 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 3);
  _331 = _330;
  *_331 = MEM[(const struct vec &)_119];

  <bb 3> :
  axis ={v} {CLOBBER};
  temp ={v} {CLOBBER};
  Rotate ={v} {CLOBBER};

  <bb 4> :
<L1>:
  return <retval>;

}



;; Function glm::vec<4, float, (glm::qualifier)0>::operator+=<float> (_ZN3glm3vecILi4EfLNS_9qualifierE0EEpLIfEERS2_RKNS0_ILi4ET_LS1_0EEE, funcdef_no=3908, decl_uid=103214, cgraph_uid=1248, symbol_order=1252)

Before removal of unreachable regions:
Eh tree:
   1 cleanup
Reachable regions: n_bits = 2, set = {}
Reachable landing pads: n_bits = 1, set = {}
Removing unreachable region 1


After removal of unreachable regions:


glm::vec<4, float, (glm::qualifier)0>::operator+=<float> (struct vec * const this, const struct vec & v)
{
  struct vec D.103227;
  struct vec & D.105655;
  struct vec & _6;

  <bb 2> :
  D.103227 = *v_2(D);
  *this_4(D) = glm::detail::compute_vec4_add<float, (glm::qualifier)0, false>::call (this_4(D), &D.103227);
  _6 = this_4(D);
  D.103227 ={v} {CLOBBER};

  <bb 3> :
<L1>:
  return _6;

}



;; Function glm::operator+<float, (glm::qualifier)0> (_ZN3glmplIfLNS_9qualifierE0EEENS_3vecILi4ET_XT0_EEERKS4_S6_, funcdef_no=3907, decl_uid=103189, cgraph_uid=1249, symbol_order=1253)

Before removal of unreachable regions:
Eh tree:
   2 must_not_throw
   1 cleanup land:{1,<L2>}
Reachable regions: n_bits = 3, set = {}
Reachable landing pads: n_bits = 2, set = {}
Removing unreachable region 1
Removing unreachable region 2


After removal of unreachable regions:


glm::operator+<float, (glm::qualifier)0> (const struct vec & v1, const struct vec & v2)
{
  struct vec & D.105652;
  struct vec D.103213;
  struct vec & _1;
  struct vec & _7;

  <bb 2> :
  D.103213 = *v1_3(D);
  _7 = glm::vec<4, float, (glm::qualifier)0>::operator+=<float> (&D.103213, v2_5(D));
  _1 = _7;
  <retval> = MEM[(const struct vec &)_1];
  D.103213 ={v} {CLOBBER};

  <bb 3> :
<L1>:
  return <retval>;

}



;; Function glm::translate<float, (glm::qualifier)0> (_ZN3glm9translateIfLNS_9qualifierE0EEENS_3matILi4ELi4ET_XT0_EEERKS4_RKNS_3vecILi3ES3_XT0_EEE, funcdef_no=3906, decl_uid=100871, cgraph_uid=1250, symbol_order=1254)

Before removal of unreachable regions:
Eh tree:
   10 must_not_throw
   1 cleanup land:{1,<L5>}
     9 must_not_throw
     2 cleanup land:{2,<L4>}
       8 must_not_throw
       3 cleanup land:{3,<L3>}
         7 must_not_throw
         4 cleanup land:{4,<L2>}
           6 must_not_throw
           5 cleanup land:{5,<L1>}
Reachable regions: n_bits = 11, set = {1 2 3 4 5 }
Reachable landing pads: n_bits = 6, set = {1 2 3 4 5 }
Removing unreachable region 6
Removing unreachable region 7
Removing unreachable region 8
Removing unreachable region 9
Removing unreachable region 10


After removal of unreachable regions:
Eh tree:
   1 cleanup land:{1,<L5>}
     2 cleanup land:{2,<L4>}
       3 cleanup land:{3,<L3>}
         4 cleanup land:{4,<L2>}
           5 cleanup land:{5,<L1>}


Removing basic block 13
Removing basic block 12
Removing basic block 11
Removing basic block 10
Removing basic block 9
Removing unreachable region 1
Removing unreachable region 2
Removing unreachable region 3
Removing unreachable region 4
Removing unreachable region 5
Merging blocks 2 and 3
Merging blocks 2 and 4
Merging blocks 2 and 5
Merging blocks 2 and 6
Merging blocks 2 and 7
glm::translate<float, (glm::qualifier)0> (const struct mat & m, const struct vec & v)
{
  struct col_type & D.105679;
  const struct col_type & D.105678;
  const float & D.105677;
  const struct col_type & D.105676;
  const float & D.105675;
  const struct col_type & D.105674;
  const float & D.105673;
  const struct col_type & D.105672;
  struct mat Result [value-expr: <retval>];
  struct col_type & D.105670;
  struct vec D.103208;
  struct vec D.103209;
  struct vec D.103210;
  struct vec D.103211;
  struct vec D.103232;
  const struct col_type & _1;
  const float & _2;
  const struct col_type & _3;
  const float & _4;
  const struct col_type & _5;
  const float & _6;
  const struct col_type & _7;
  const struct col_type & _17;
  const float & _20;
  const struct col_type & _22;
  const float & _25;
  const struct col_type & _27;
  const float & _30;
  const struct col_type & _32;
  struct col_type & _37;
  struct col_type & _38;

  <bb 2> :
  <retval> = *m_14(D);
  _17 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_14(D), 3);
  _1 = _17;
  _20 = glm::vec<3, float, (glm::qualifier)0>::operator[] (v_18(D), 2);
  _2 = _20;
  _22 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_14(D), 2);
  _3 = _22;
  D.103211 = glm::operator*<float, (glm::qualifier)0> (_3, _2); [return slot optimization]
  _25 = glm::vec<3, float, (glm::qualifier)0>::operator[] (v_18(D), 1);
  _4 = _25;
  _27 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_14(D), 1);
  _5 = _27;
  D.103209 = glm::operator*<float, (glm::qualifier)0> (_5, _4); [return slot optimization]
  _30 = glm::vec<3, float, (glm::qualifier)0>::operator[] (v_18(D), 0);
  _6 = _30;
  _32 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (m_14(D), 0);
  _7 = _32;
  D.103208 = glm::operator*<float, (glm::qualifier)0> (_7, _6); [return slot optimization]
  D.103210 = glm::operator+<float, (glm::qualifier)0> (&D.103208, &D.103209); [return slot optimization]
  D.103232 = glm::operator+<float, (glm::qualifier)0> (&D.103210, &D.103211); [return slot optimization]
  _37 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 3);
  _38 = _37;
  *_38 = glm::operator+<float, (glm::qualifier)0> (&D.103232, _1);
  D.103232 ={v} {CLOBBER};
  D.103210 ={v} {CLOBBER};
  D.103208 ={v} {CLOBBER};
  D.103209 ={v} {CLOBBER};
  D.103211 ={v} {CLOBBER};

  <bb 3> :
<L0>:
  return <retval>;

}



;; Function glm::perspectiveRH_NO<float> (_ZN3glm16perspectiveRH_NOIfEENS_3matILi4ELi4ET_LNS_9qualifierE0EEES2_S2_S2_S2_, funcdef_no=4074, decl_uid=103236, cgraph_uid=1415, symbol_order=1419)

Before removal of unreachable regions:
Eh tree:
   2 must_not_throw
   1 cleanup land:{1,<L6>}
Reachable regions: n_bits = 3, set = {1 }
Reachable landing pads: n_bits = 2, set = {1 }
Removing unreachable region 2


After removal of unreachable regions:
Eh tree:
   1 cleanup land:{1,<L6>}


Removing basic block 20
Removing unreachable region 1
Merging blocks 3 and 4
Merging blocks 7 and 8
Merging blocks 7 and 9
Merging blocks 7 and 10
Merging blocks 7 and 11
Merging blocks 7 and 12
Merging blocks 7 and 13
Merging blocks 7 and 14
Merging blocks 7 and 15
Merging blocks 7 and 16
Merging blocks 7 and 17
glm::perspectiveRH_NO<float> (float fovy, float aspect, float zNear, float zFar)
{
  float & D.105714;
  struct col_type & D.105713;
  float & D.105712;
  struct col_type & D.105711;
  float & D.105710;
  struct col_type & D.105709;
  float & D.105708;
  struct col_type & D.105707;
  float & D.105706;
  struct col_type & D.105705;
  float D.105704;
  struct mat Result [value-expr: <retval>];
  const float tanHalfFovy;
  bool iftmp.60;
  float _1;
  float _2;
  float _3;
  float _4;
  float _5;
  float tanHalfFovy.61_6;
  float _7;
  struct col_type & _8;
  float & _9;
  float _10;
  float tanHalfFovy.62_11;
  struct col_type & _12;
  float & _13;
  float _14;
  float _15;
  float _16;
  float _17;
  struct col_type & _18;
  float & _19;
  float _20;
  struct col_type & _21;
  float & _22;
  float _23;
  float _24;
  float _25;
  float _26;
  struct col_type & _27;
  float & _28;
  float _29;
  float _36;
  bool iftmp.60_38;
  bool iftmp.60_39;
  struct col_type & _45;
  float & _47;
  struct col_type & _50;
  float & _52;
  struct col_type & _57;
  float & _59;
  struct col_type & _62;
  float & _64;
  struct col_type & _67;
  float & _69;

  <bb 2> :
  _1 = std::numeric_limits<float>::epsilon ();
  _2 = aspect_34(D) - _1;
  _36 = glm::abs<float> (_2);
  _3 = _36;
  if (_3 > 0.0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _assert ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", "C:/glm/glm/ext/matrix_clip_space.inl", 251);
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.60_39 = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.60_38 = 0;

  <bb 6> :
  _4 = fovy_40(D) / 2.0e+0;
  _5 = std::tan (_4);
  tanHalfFovy = _5;
  <retval> = {};
  tanHalfFovy.61_6 = tanHalfFovy;
  _7 = aspect_34(D) * tanHalfFovy.61_6;
  _45 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 0);
  _8 = _45;
  _47 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_8, 0);
  _9 = _47;
  _10 = 1.0e+0 / _7;
  *_9 = _10;
  tanHalfFovy.62_11 = tanHalfFovy;
  _50 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 1);
  _12 = _50;
  _52 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_12, 1);
  _13 = _52;
  _14 = 1.0e+0 / tanHalfFovy.62_11;
  *_13 = _14;
  _15 = zFar_54(D) + zNear_55(D);
  _16 = -_15;
  _17 = zFar_54(D) - zNear_55(D);
  _57 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 2);
  _18 = _57;
  _59 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_18, 2);
  _19 = _59;
  _20 = _16 / _17;
  *_19 = _20;
  _62 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 2);
  _21 = _62;
  _64 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_21, 3);
  _22 = _64;
  *_22 = -1.0e+0;
  _23 = zFar_54(D) * 2.0e+0;
  _24 = zNear_55(D) * _23;
  _25 = -_24;
  _26 = zFar_54(D) - zNear_55(D);
  _67 = glm::mat<4, 4, float, (glm::qualifier)0>::operator[] (&<retval>, 3);
  _27 = _67;
  _69 = glm::vec<4, float, (glm::qualifier)0>::operator[] (_27, 2);
  _28 = _69;
  _29 = _25 / _26;
  *_28 = _29;

  <bb 7> :
  tanHalfFovy ={v} {CLOBBER};

  <bb 8> :
<L5>:
  return <retval>;

}



;; Function glm::detail::compute_dot<glm::vec<3, float, (glm::qualifier)0>, float, false>::call (_ZN3glm6detail11compute_dotINS_3vecILi3EfLNS_9qualifierE0EEEfLb0EE4callERKS4_S7_, funcdef_no=4222, decl_uid=105136, cgraph_uid=1564, symbol_order=1568)

Before removal of unreachable regions:
Eh tree:
   1 cleanup
Reachable regions: n_bits = 2, set = {}
Reachable landing pads: n_bits = 1, set = {}
Removing unreachable region 1


After removal of unreachable regions:


glm::detail::compute_dot<glm::vec<3, float, (glm::qualifier)0>, float, false>::call (const struct vec & a, const struct vec & b)
{
  struct vec tmp;
  float D.105616;
  float _1;
  float _2;
  float _3;
  float _4;
  float _9;

  <bb 2> :
  tmp = glm::operator*<float, (glm::qualifier)0> (a_6(D), b_7(D)); [return slot optimization]
  _1 = tmp.D.95554.x;
  _2 = tmp.D.95560.y;
  _3 = _1 + _2;
  _4 = tmp.D.95566.z;
  _9 = _3 + _4;
  tmp ={v} {CLOBBER};

  <bb 3> :
<L1>:
  return _9;

}


